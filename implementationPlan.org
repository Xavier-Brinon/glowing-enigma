#+title: Working with OpenSpec with multiple Claude profiles
#+author: HaQadosch
#+date: [2026-02-15 Sun]
#+startup: indent
#+property: header-args :results output
* Book Tracker App — Implementation Plan

** Context

Build a personal "next books to read" app — a todo list for books
where each entry captures not just title/author, but *how you heard
about the book* and *what you expect from it*. These two fields are
the app's differentiator.

Tech stack:
- TanStack Start (full-stack framework, see [[file:ADR/0003-switch-to-tanstack-start.org][ADR 0003]])
- TanStack Router (built into Start)
- TanStack Query (built into Start)
- ~node:sqlite~ (see [[file:ADR/0002-switch-to-node-sqlite.org][ADR 0002]])

all running locally, single process.

** Architecture

#+begin_src shell
book-tracker/
├── src/
│   ├── routes/
│   │   ├── __root.tsx          # Root layout (nav, shell)
│   │   ├── index.tsx           # Book list + server functions
│   │   └── books/
│   │       ├── new.tsx         # Add book form + createServerFn
│   │       └── $bookId.tsx     # Edit/delete + createServerFn
│   ├── components/
│   │   ├── BookCard.tsx        # Single book display card
│   │   └── BookForm.tsx        # Reusable form (add + edit)
│   └── lib/
│       └── db.ts               # node:sqlite setup, schema, queries
├── app.config.ts               # TanStack Start config
├── package.json
└── tsconfig.json
#+end_src


*Data flow:*
React components
→ TanStack Query (useQuery/useMutation)
→ =createServerFn= (server functions)
→ ~node:sqlite~
→ SQLite file (*books.db*)

** Database Schema

Single *books* table:

| Column       | Type    | Notes                                     |
|--------------+---------+-------------------------------------------|
| id           | INTEGER | Primary key, autoincrement                |
| title        | TEXT    | Required                                  |
| author       | TEXT    | Required                                  |
| heard_from   | TEXT    | How you heard about it (podcast, friend…) |
| expectations | TEXT    | What you expect to get from reading it    |
| status       | TEXT    | /to-read/, /reading/, /done/              |
| created_at   | TEXT    | ISO timestamp, default now                |

** Server Functions

No REST API — CRUD operations are handled via =createServerFn=:

| Function    | Method | Description         |
|-------------+--------+---------------------|
| getBooks    | GET    | List all books      |
| getBook     | GET    | Get single book     |
| createBook  | POST   | Create a book       |
| updateBook  | POST   | Update a book       |
| deleteBook  | POST   | Delete a book       |

Server functions are defined in route files and called directly from
components. TanStack Start handles the RPC transport.

** Implementation Phases

*** Phase 1: Project scaffolding
- Scaffold TanStack Start project
- Configure =app.config.ts=
- Pin Node.js version (22.5+) in =.nvmrc=
- Single =npm run dev= starts everything

*** Phase 2: Database + Server Functions
- Create =src/lib/db.ts= :: initialize ~node:sqlite~, create *books* table
- Create server functions (=createServerFn=) for all CRUD operations
- Test server functions from a route loader

*** Phase 3: Book list page (Read)
- Wire up `routes/index.tsx` with `useQuery` to fetch and display all books
- Build `BookCard` component showing title, author, status, heard_from, expectations
- Group or filter by status (`to-read` / `reading` / `done`)

*** Phase 4: Add book form (Create)
- Build `BookForm` component with fields: title, author, heard_from, expectations, status
- Wire `routes/books/new.tsx` with `useMutation` to POST, then navigate back to list
- Invalidate `['books']` query on success

*** Phase 5: Edit + Delete (Update/Delete)
- Wire `routes/books/$bookId.tsx` — load book with `useQuery`, edit with `BookForm`
- Add delete button with confirmation
- Both use `useMutation` and invalidate queries on success

*** Phase 6: Polish
- Quick status toggle (click to cycle `to-read` → `reading` → `done`) on the list
- Basic styling (clean, minimal CSS)
- Empty state when no books exist

** How to Run (after implementation)
#+begin_src shell
  # Install dependencies
  npm install

  # Run both frontend and API server
  npm run dev
#+end_src

App runs on =http://localhost:3000= (single process, no separate API server).

** Verification

- Add a book via the form → appears in the list
- Edit a book → changes persist after page refresh (proves DB works)
- Delete a book → removed from list
- Status toggle works on the list view
- Refresh browser → all data still there (SQLite persistence)
