#+title: Resource Management Assessment: Bloom's Taxonomy
#+author: Claude Code
#+date: [2026-02-21]
#+startup: indent
#+startup: showall
#+OPTIONS: toc:3

*Prerequisites*:
- [[./teaching_explicit_resource_management.org][Explicit Resource Management: =using= and =await using=]]
- [[./teaching_resource_management_architecture.org][Going Deeper: Resource Management in Architecture and Operations]]

-----

* Table of Contents                                                     :TOC:
(Auto-generated by Org-mode on export via =#+OPTIONS: toc:3=)

-----

* Introduction

This assessment contains 66 questions organised by the six levels of
the *revised Bloom's taxonomy*. Questions are open-ended at every
level — there are no multiple-choice answers. Each level demands a
different kind of thinking:

#+begin_example
BLOOM'S TAXONOMY (REVISED)

  ┌──────────────────┐
  │  6. CREATE       │  Design, produce, construct
  ├──────────────────┤
  │  5. EVALUATE     │  Justify, critique, defend
  ├──────────────────┤
  │  4. ANALYSE      │  Compare, differentiate, organise
  ├──────────────────┤
  │  3. APPLY        │  Use in new situations
  ├──────────────────┤
  │  2. UNDERSTAND   │  Explain, summarise, predict
  ├──────────────────┤
  │  1. REMEMBER     │  Recall, identify, list
  └──────────────────┘
#+end_example

** How to Use This Assessment

*** Self-Study Mode

- Work through levels sequentially — each builds on the previous
- Attempt your answer *before* unfolding the solution
- At Levels 1-2, aim for 1-3 sentence answers
- At Level 3, expect to write short code snippets
- At Levels 4-5, write paragraph-length responses
- At Level 6, produce designs with code and/or diagrams

Questions within each level are ordered from easier to harder.

*** Spaced Repetition Mode (org-drill)

Levels 1-3 are tagged =:drill:= and work as *spaced repetition
flashcards* using [[https://orgmode.org/worg/org-contrib/org-drill.html][org-drill]].

#+begin_example
HYBRID APPROACH

  L1 Remember ──┐
  L2 Understand ├──→ :drill: tagged  ──→  M-x org-drill
  L3 Apply     ─┘    (flashcards)         spaced repetition

  L4 Analyse  ──┐
  L5 Evaluate  ─├──→ no tag           ──→  self-study exercises
  L6 Create   ──┘    (unchanged)           work through manually
#+end_example

*Setup:*

1. Install =org-drill= (available in MELPA: =M-x package-install RET
   org-drill RET=)
2. Run =M-x org-drill= in this file
3. For each card: read the question, compose your answer mentally,
   press =RET= to reveal, then rate yourself 0-5
4. org-drill schedules the next review automatically using the SM5
   algorithm

*Rating guide:*

| Rating | Meaning                          | Next review        |
|--------+----------------------------------+--------------------|
|      0 | Total blackout — no recall       | Again immediately  |
|      1 | Wrong, but recognised answer     | Again this session |
|      2 | Wrong, but answer felt close     | Next session       |
|      3 | Correct, with significant effort | ~3 days            |
|      4 | Correct, after some thought      | ~7 days            |
|      5 | Instant, effortless recall       | ~16+ days          |

For L3 (Apply) cards, mentally compose the code structure before
revealing. You don't need a perfect syntax match — focus on whether
you got the key concepts right (e.g., =using= placement, disposal
order, error handling approach).

-----

* Level 1: Remember

/Recall facts, definitions, and basic mechanics./

*** Q1. Name the two symbols used for disposal in JavaScript  :drill:
:PROPERTIES:
:ID:       DD4CCE7F-1453-4276-ACAF-B2B690F374B0
:END:

What are the two well-known symbols that make an object compatible
with =using= and =await using= respectively?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=Symbol.dispose= (for =using=, synchronous cleanup) and
=Symbol.asyncDispose= (for =await using=, asynchronous cleanup).

*** Q2. State the disposal order for multiple =using= declarations  :drill:
:PROPERTIES:
:ID:       889E02E0-021B-4E94-998C-100DF28D7657
:END:

If three resources are declared with =using= in the same scope,
in what order are they disposed? Name the ordering principle.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

LIFO — last declared, first disposed. The third resource is disposed
first, then the second, then the first.

*** Q3. Name the error type that preserves both a body error and a disposal error  :drill:
:PROPERTIES:
:ID:       E05734E0-E24A-45B7-8194-E4E3DE1BBFC4
:END:

When a =using= block's body throws and the disposer also throws,
what type wraps both errors? Name its two key properties.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=SuppressedError=. Its =suppressed= property holds the original body
error; its =error= property holds the disposal error.

*** Q4. What TypeScript configuration is needed for =using=?  :drill:
:PROPERTIES:
:ID:       4319B893-5979-4597-9FA8-5CB4A1D39BE3
:END:

Name the =compilerOptions= fields (target and lib) required for
TypeScript to recognise =using= and =await using=.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=target: "ES2024"= (or later) and =lib= must include
="esnext.disposable"=.

*** Q5. What does RAII stand for, and where did it originate?  :drill:
:PROPERTIES:
:ID:       3747E416-3067-4319-B0D8-4388040D73F4
:END:

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Resource Acquisition Is Initialisation. It originated in C++ in the
1980s (attributed to Bjarne Stroustrup).

*** Q6. Name the three resource ownership models  :drill:
:PROPERTIES:
:ID:       2D8AF16C-25CF-4E9C-85B9-A85FC2D04123
:END:

List the three ownership models described in the Going Deeper document
and give a one-line description of each.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

the three models are:
- Lexical :: resource lifetime tied to a code block (=using=)
- Container :: resource lifetime tied to a class instance
- Pool :: resource created, lent, and reclaimed by a shared pool

*** Q7. What happens when =using= is assigned =null= or =undefined=?  :drill:
:PROPERTIES:
:ID:       CB484BC5-7546-4C8A-9861-A50EC296A01F
:END:

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

The disposal step is skipped — no error is thrown. This supports
conditional resource acquisition patterns.

*** Q8. Name the JavaScript API for detecting garbage-collected objects  :drill:
:PROPERTIES:
:ID:       D13669F2-3E99-4BEE-A816-B9C28F00A440
:END:

What built-in class lets you register a callback that fires when an
object is garbage-collected?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=FinalizationRegistry=.

*** Q9. What Linux error code signals file descriptor exhaustion?  :drill:
:PROPERTIES:
:ID:       0B40BF6B-82FA-4311-8332-E916829E7DDE
:END:

Name the error code and the typical default limit per process.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=EMFILE= ("too many open files"). The default limit is typically 1024
file descriptors per process.

*** Q10. Name the class that allows dynamic registration of disposables at runtime  :drill:
:PROPERTIES:
:ID:       F42A4696-2ED7-4646-9E00-D3B1B979F2F2
:END:

What standard class lets you call =.use(resource)= in a loop or
conditionally, collecting resources for LIFO disposal?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=DisposableStack= (synchronous) and =AsyncDisposableStack=
(asynchronous).

*** Q11. List the four registration methods on =DisposableStack=  :drill:
:PROPERTIES:
:ID:       A9DE0775-5C3E-4384-963E-98DE6D873977
:END:

Name each method and describe in one sentence what it registers.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

The four methods are:
- =.use(resource)= :: registers an object that implements =Symbol.dispose=
- =.adopt(value, fn)= :: registers a non-disposable value with a custom cleanup function
- =.defer(fn)= :: registers a cleanup callback with no associated resource
- =.move()= :: transfers all registrations to a new stack without running disposers

-----

* Level 2: Understand

/Explain concepts in your own words. Predict behaviour./

*** Q1. Explain why LIFO is the natural disposal order  :drill:
:PROPERTIES:
:ID:       BCCD7564-B167-4BD5-BD59-D59280DBD9CD
:END:

In your own words, explain why resources should be disposed in
reverse declaration order rather than forward order.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Resources declared later may depend on resources declared earlier.
For example, a transaction opened on a database connection depends
on that connection being open. If you closed the connection first
(FIFO), the transaction disposal would fail. LIFO ensures dependent
resources are cleaned up before their dependencies.

*** Q2. Predict what the caller receives when a =using=-declared variable is returned  :drill:
:PROPERTIES:
:ID:       784AF84D-C8BE-4FCB-B02A-087540606DCA
:END:

A function declares =using db = createDatabaseConnection()= and then
returns =db=. Describe what the caller gets and why.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

The caller receives a disposed (closed) database connection. =using=
triggers =[Symbol.dispose]()= when the function's scope exits, which
happens /before/ the return value reaches the caller. The return
value is evaluated, then disposal runs, then the value is delivered —
but the value is a reference to the now-disposed object.

*** Q3. Explain the difference between request-scoped and application-scoped resources  :drill:
:PROPERTIES:
:ID:       3F605297-1FE0-4327-B126-29F2E3621F71
:END:

Describe the lifetime of each, and explain why they require different
cleanup strategies.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Request-scoped resources live for a single operation (one HTTP
request, one function call) and are disposed immediately after.
=using= handles this naturally. Application-scoped resources live for
the entire process lifetime (a connection pool, a cache client) and
are only disposed on process shutdown. They require a =SIGTERM=
handler or framework lifecycle hook because no lexical scope exit
triggers their cleanup during normal operation.

*** Q4. Explain why =FinalizationRegistry= is a safety net, not a strategy  :drill:
:PROPERTIES:
:ID:       E4EED6D7-4999-4FF8-B71E-BF0F0C432BA8
:END:

A colleague suggests relying on =FinalizationRegistry= instead of
=using= for resource cleanup. Explain why this is insufficient.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=FinalizationRegistry= callbacks fire when the garbage collector
reclaims an object, but GC timing is non-deterministic — it is
triggered by memory pressure, not by resource needs. A database
connection might remain open for minutes or hours after it is no
longer used, consuming a connection slot. Under load, connections
accumulate faster than the GC reclaims them. The GC optimises for
memory, not for external resource limits (connection counts, file
descriptors).

*** Q5. Explain what =SuppressedError= solves compared to plain =try/finally=  :drill:
:PROPERTIES:
:ID:       0A7E0B57-3E6E-439A-B02B-33E625ACE24B
:END:

Describe the specific problem with error handling in =try/finally=
that =SuppressedError= addresses.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

In a =try/finally= block, if the =try= body throws and the =finally=
block also throws, the original error from the body is silently
replaced by the =finally= error. The root cause is lost.
=SuppressedError= wraps both: the disposal error in =.error= and the
original body error in =.suppressed=. This preserves the causal chain
so that debugging can trace back to the real problem.

*** Q6. Explain why a circuit breaker in the OPEN state rejects immediately  :drill:
:PROPERTIES:
:ID:       D0448F84-59BC-4DF2-BC77-10E8E0FB0C64
:END:

Describe what happens when a circuit breaker in the OPEN state
receives a resource acquisition request, and explain the reasoning.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

The request is immediately rejected without attempting acquisition.
The OPEN state means the downstream resource has been failing
repeatedly. Attempting to acquire would waste time (the request would
likely fail or timeout) and would add pressure to an already-failing
system. After a cooldown period, the breaker moves to HALF-OPEN and
allows a single test request to check recovery.

*** Q7. Explain why capturing the stack trace at acquisition time aids leak detection  :drill:
:PROPERTIES:
:ID:       05B91EB7-74C9-4338-94A5-66A5241D92FC
:END:

An =InstrumentedConnection= captures =new Error().stack= in its
constructor. Explain why this is more useful than capturing it in
=[Symbol.dispose]()=.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

When a leak is detected (the resource was never disposed), you need
to know /where the resource was created/ — which call site forgot to
use =using= or =try/finally=. The disposal method never runs for
leaked resources, so a stack trace there is useless. The constructor
stack trace leads directly to the line that created the resource
without proper cleanup.

*** Q8. Explain the relationship between dependency injection and resource ownership  :drill:
:PROPERTIES:
:ID:       D0823F2F-7122-4B1E-9547-E2E8A5670F75
:END:

How does separating resource creation from resource usage affect who
is responsible for cleanup?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

When a component creates its own resources, it must also manage
cleanup — mixing business logic with resource lifecycle. With
dependency injection, the composition root creates resources and
passes them to components as borrowers. Borrowers use the resource
but have no cleanup responsibility. Cleanup becomes a centralised,
top-level architectural decision, reducing the risk of scattered
leaks across the codebase.

*** Q9. Predict the behaviour when =using= is used inside a =for= loop body  :drill:
:PROPERTIES:
:ID:       E35FEB84-AEF1-4967-9BB7-9821305BA679
:END:

What happens to the resource at each iteration? Contrast this with
Go's =defer= in the same position.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

With =using= inside a loop body, the resource is disposed at the end
of each iteration — the block scope exits and re-enters. Each
iteration gets a fresh resource. With Go's =defer=, the deferred call
accumulates until the enclosing /function/ returns. If the loop runs
100 times, 100 resources are held simultaneously until the function
exits. Go requires an immediately-invoked function to get
per-iteration cleanup.

*** Q10. Explain why pool exhaustion looks different from a database crash to an SRE  :drill:
:PROPERTIES:
:ID:       122C828B-2F03-40A4-839D-2895E600A6F9
:END:

Describe the symptoms of each and how an SRE would distinguish them.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A database crash produces connection /errors/ (TCP reset, "connection
refused"). Pool exhaustion produces connection /timeouts/ — the pool
has no available connection to lend, so requests wait indefinitely.
The critical difference: the database is healthy during pool
exhaustion. An SRE can distinguish them by: (1) running a direct
health check bypassing the pool, (2) checking pool metrics (active
= max, idle = 0), (3) checking connection lifetimes for abnormally
old connections, (4) checking the database server's own connection
count.

*** Q11. Explain why =DisposableStack.move()= is necessary  :drill:
:PROPERTIES:
:ID:       C3AD4403-CC85-4738-95DE-3B0F5767D72F
:END:

A factory function uses =using stack = new DisposableStack()= to build
a set of resources and then returns the stack. Without =.move()=, what
happens? Explain why =.move()= solves the problem.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Without =.move()=, the =using= declaration disposes the stack (and all
its registered resources) when the factory function's scope exits —
before the caller receives the return value. The caller gets a
disposed, empty stack. This is the same problem as returning a =using=
variable directly.

=.move()= creates a new stack containing all the registrations, then
marks the original stack as disposed /without running any disposers/.
The original =using= declaration sees an already-disposed stack on
scope exit and does nothing. The new stack (returned to the caller)
retains ownership and will dispose its resources when the caller's
scope exits.

*** Q12. Explain how =.adopt()= differs from wrapping with a class  :drill:
:PROPERTIES:
:ID:       E64A570C-055D-4D7D-A7FA-C7FAA2C1C87D
:END:

Both =stack.adopt(fd, closeFn)= and creating a =DisposableWrapper=
class can make a non-disposable value work with =using=. Explain when
you would choose each approach.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=.adopt()= is inline and ephemeral — it pairs a value with a cleanup
function for a single use site. No class definition, no reusable type.
Use it for one-off cases: a file descriptor, a temporary directory, a
third-party object you only use in one function.

A wrapper class creates a reusable, named =Disposable= type that can
be used with =using= anywhere in the codebase. Use it when the
non-disposable value is used in multiple places or when consumers
should not need to know the cleanup logic.

Rule of thumb: if you write =.adopt()= for the same value type more
than twice, promote it to a wrapper class.

-----

* Level 3: Apply

/Use knowledge in new, concrete situations./

*** Q1. Write a =using= declaration for a function that queries a database and returns the result  :drill:
:PROPERTIES:
:ID:       3CDB6DA3-F991-43B7-8213-D5795413FD36
:END:

Given =createDatabaseConnection()= from our codebase, write a
function =getBookCount()= that returns the number of books in the
database. Ensure the connection is cleaned up on any exit path.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
function getBookCount(): number {
  using db = createDatabaseConnection()
  const result = db.prepare('SELECT COUNT(*) as n FROM books').get() as { n: number }
  return result.n
}
#+end_src

The connection is disposed after the return value is computed,
regardless of whether an exception occurs.

*** Q2. Make a third-party class compatible with =using=  :drill:
:PROPERTIES:
:ID:       B2CA5B60-AE0D-434E-B07D-335B97BF7A5B
:END:

You receive a =RedisClient= class that has a =.quit()= method but
does not implement =Symbol.dispose=. Write a wrapper class that makes
it usable with =using=.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
class DisposableRedis implements Disposable {
  constructor(readonly client: RedisClient) {}

  [Symbol.dispose](): void {
    this.client.quit()
  }
}

// Usage.
using redis = new DisposableRedis(new RedisClient({ host: 'localhost' }))
redis.client.set('key', 'value')
#+end_src

Use composition (wrapping) rather than inheritance or monkey-patching.

*** Q3. Use =DisposableStack= to manage a dynamic number of resources  :drill:
:PROPERTIES:
:ID:       6B9AB546-BAF0-492A-879D-7B0CC6DEA115
:END:

Write a function that receives an array of file paths, opens a
database connection for each, runs a PRAGMA command, and disposes all
connections when done.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
function configureAll(paths: string[]): void {
  using stack = new DisposableStack()

  for (const path of paths) {
    const db = stack.use(new DatabaseSync(path))
    db.exec('PRAGMA journal_mode=WAL')
  }
  // All connections disposed here in LIFO order.
}
#+end_src

=DisposableStack= is needed because the number of resources is not
known at write time — =using= alone would require a fixed number of
declarations.

*** Q4. Add =using= to an existing test to prevent cleanup leaks  :drill:
:PROPERTIES:
:ID:       EAF28557-9E91-4058-BDB8-11134B9693F4
:END:

This test leaks a connection when the assertion fails. Rewrite it
to ensure cleanup on all exit paths:

#+begin_src javascript
it('finds a book by ID', () => {
  const db = new DatabaseSync(':memory:')
  db.exec('CREATE TABLE books (id INTEGER, title TEXT)')
  db.exec("INSERT INTO books VALUES (1, 'Dune')")
  const row = db.prepare('SELECT * FROM books WHERE id = 1').get()
  expect(row).toEqual({ id: 1, title: 'Dune' })
  db.close()
})
#+end_src

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
it('finds a book by ID', () => {
  using db = new DatabaseSync(':memory:')
  db.exec('CREATE TABLE books (id INTEGER, title TEXT)')
  db.exec("INSERT INTO books VALUES (1, 'Dune')")
  const row = db.prepare('SELECT * FROM books WHERE id = 1').get()
  expect(row).toEqual({ id: 1, title: 'Dune' })
})
#+end_src

Replace =const= with =using= and remove the manual =db.close()=.
If the =expect= throws, =using= still triggers disposal.

*** Q5. Write a conditional =using= declaration  :drill:
:PROPERTIES:
:ID:       FD76AF6F-6A32-41AB-BE15-A71B89BEBFEB
:END:

Write a function that optionally opens a database connection based on
a feature flag, queries it if available, and returns a default value
otherwise. Use =using= with a nullish value.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
function getBookCountIfEnabled(): number {
  using db = isFeatureEnabled('database')
    ? createDatabaseConnection()
    : null

  if (!db) return 0

  const result = db.prepare('SELECT COUNT(*) as n FROM books').get() as { n: number }
  return result.n
}
#+end_src

=using= accepts =null= and skips disposal — no error, no special
handling needed.

*** Q6. Implement =Symbol.dispose= on a class that wraps two resources  :drill:
:PROPERTIES:
:ID:       398C69B6-AE9E-4EEF-BDD0-422198F07826
:END:

Write a =DatabaseBackup= class that holds both a source and a
destination =DatabaseSync= connection. Implement =[Symbol.dispose]=
to close both in the correct order.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
class DatabaseBackup implements Disposable {
  private source: DatabaseSync
  private destination: DatabaseSync

  constructor(sourcePath: string, destPath: string) {
    this.source = new DatabaseSync(sourcePath)
    this.destination = new DatabaseSync(destPath)
  }

  run(): void {
    const rows = this.source.prepare('SELECT * FROM books').all()
    for (const row of rows) {
      this.destination.prepare('INSERT INTO books VALUES (?, ?)').run(
        (row as Record<string, unknown>).id,
        (row as Record<string, unknown>).title
      )
    }
  }

  [Symbol.dispose](): void {
    // Close destination first (created last, depends on source being open).
    this.destination.close()
    this.source.close()
  }
}
#+end_src

*** Q7. Place a =using= declaration correctly with respect to an early return  :drill:
:PROPERTIES:
:ID:       86350D21-1249-4E93-ABD4-72F9366E1C73
:END:

This function has a resource leak on the guard clause. Fix it by
repositioning the =using= declaration:

#+begin_src javascript
function findBook(id: number): Book | null {
  if (!isValidId(id)) return null
  using db = createDatabaseConnection()
  return db.prepare('SELECT * FROM books WHERE id = ?').get(id) as Book | null
}
#+end_src

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

This is actually already correct — the =using= declaration is
/after/ the guard clause, so no connection is opened when =id= is
invalid. No resource is leaked because no resource is acquired on the
early return path. The =using= placement here is ideal: acquire only
when needed.

The buggy version would be:

#+begin_src javascript
function findBook(id: number): Book | null {
  using db = createDatabaseConnection()  // acquired unconditionally
  if (!isValidId(id)) return null         // db disposed here — correct but wasteful
  return db.prepare('SELECT * FROM books WHERE id = ?').get(id) as Book | null
}
#+end_src

Both are leak-free, but the first avoids unnecessary acquisition.

*** Q8. Register a shutdown handler for an application-scoped resource  :drill:
:PROPERTIES:
:ID:       E4E8BB83-F3A7-4827-B14A-87747BD9ED10
:END:

Write a =SIGTERM= handler that disposes a connection pool and an HTTP
server, with a 10-second timeout and parallel disposal.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down...')

  const timeout = setTimeout(() => {
    console.error('Shutdown timeout exceeded. Forcing exit.')
    process.exit(1)
  }, 10_000)

  const results = await Promise.allSettled([
    new Promise<void>((resolve) => server.close(() => resolve())),
    pool[Symbol.asyncDispose](),
  ])

  clearTimeout(timeout)

  const failures = results.filter((r) => r.status === 'rejected')
  process.exit(failures.length > 0 ? 1 : 0)
})
#+end_src

Key points: timeout prevents hanging, =Promise.allSettled= ensures
both disposal attempts run, exit code reflects success/failure.

*** Q9. Write a =SuppressedError= handler that logs both errors  :drill:
:PROPERTIES:
:ID:       2E895C01-2878-455E-8209-1A1460B77B88
:END:

Write a =try/catch= block around a =using= scope that detects
=SuppressedError= and logs both the original and disposal errors
separately.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
try {
  using db = createDatabaseConnection()
  throw new Error('query failed')
} catch (error) {
  if (error instanceof SuppressedError) {
    console.error('Original error:', error.suppressed)
    console.error('Disposal error:', error.error)
  } else {
    console.error('Error:', error)
  }
}
#+end_src

*** Q10. Write an =async [Symbol.asyncDispose]= method that drains in-flight work  :drill:
:PROPERTIES:
:ID:       0088B20C-57B0-45AC-9924-60DC6722FEA3
:END:

Implement =[Symbol.asyncDispose]= on a class that tracks in-flight
operations and waits for them to complete before closing.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
class WorkerPool implements AsyncDisposable {
  private inFlightCount = 0
  private drainResolve: (() => void) | null = null

  async submit(work: () => Promise<void>): Promise<void> {
    this.inFlightCount++
    try {
      await work()
    } finally {
      this.inFlightCount--
      if (this.inFlightCount === 0 && this.drainResolve) {
        this.drainResolve()
      }
    }
  }

  async [Symbol.asyncDispose](): Promise<void> {
    if (this.inFlightCount > 0) {
      await new Promise<void>((resolve) => {
        this.drainResolve = resolve
      })
    }
  }
}
#+end_src

*** Q11. Use =DisposableStack.adopt()= and =.defer()= together  :drill:
:PROPERTIES:
:ID:       6E71665A-97FB-44C5-AC02-E544525DE1E5
:END:

Write a function that creates a temporary directory, opens a raw file
descriptor inside it for writing, writes a header line, and ensures
both the file and directory are cleaned up. Use =.adopt()= for the
file descriptor and =.defer()= for directory deletion.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+begin_src javascript
function writeTemporaryReport(content: string): void {
  using stack = new DisposableStack()

  const tempDir = fs.mkdtempSync('/tmp/report-')
  stack.defer(() => fs.rmSync(tempDir, { recursive: true }))

  const fd = stack.adopt(
    fs.openSync(`${tempDir}/report.csv`, 'w'),
    (fd) => fs.closeSync(fd)
  )

  fs.writeSync(fd, 'id,status\n')
  fs.writeSync(fd, content)
  // On exit: file closed (adopt, registered 2nd) then dir deleted (defer, registered 1st).
  // Wait — LIFO means defer runs AFTER adopt. But defer was registered first.
  // Correct order: fd closed (2nd registered) → dir deleted (1st registered).
}
#+end_src

The registration order matters: =.defer()= for the directory is
registered first, =.adopt()= for the file second. LIFO disposal
closes the file before deleting the directory — which is correct,
because you cannot delete a directory with an open file handle.

-----

* Level 4: Analyse

/Break down systems, compare approaches, identify relationships./

*** Q1. Compare =using= (JavaScript) with Python's =with= statement

Analyse the similarities and differences in terms of scope, error
handling, and multiple resource management.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Both tie resource lifetime to a lexical block and guarantee cleanup on
exit. Key differences: (1) Python's =with= calls =__enter__= and
=__exit__=, where =__exit__= receives the exception and can
/suppress/ it by returning =True= — JavaScript's =Symbol.dispose=
has no such suppression ability. (2) Python supports multiple
resources in one =with= statement (=with open(a) as f, open(b) as g=)
whereas JavaScript requires separate =using= declarations (though
both dispose in LIFO order). (3) Python's =__exit__= receives the
exception type, value, and traceback as arguments, allowing
context-aware cleanup; JavaScript's =Symbol.dispose= takes no
arguments.

*** Q2. Differentiate between =DisposableStack= and multiple =using= declarations

When would you use each? Analyse the structural difference.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Multiple =using= declarations are statically determined — each one is
a line in the source code. =DisposableStack= is dynamic — resources
can be registered at runtime (in loops, conditionally, or from
function return values). Use =using= when you know at write time
exactly which resources you will acquire. Use =DisposableStack= when
the set of resources depends on runtime data.

Structurally, =using= instruments each variable independently, while
=DisposableStack= aggregates multiple resources behind a single
=using stack= declaration.

*** Q3. Compare Go's =defer= with JavaScript's =using=

Analyse the scoping rules and describe a scenario where the
difference matters.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=defer= is function-scoped: deferred calls run when the enclosing
/function/ returns. =using= is block-scoped: disposal runs at the end
of the block (an =if= body, a loop iteration, a bare block).

This matters in loops. In Go, =defer= inside a loop accumulates
all deferred calls until the function exits — potentially holding
many resources simultaneously. In JavaScript, =using= inside a loop
body disposes at each iteration's end. Go developers must use an
immediately-invoked function to get per-iteration cleanup; JavaScript
gets it by default.

*** Q4. Analyse the trade-offs between request-scoped and pool-scoped resource ownership

Under what conditions would you choose one over the other? Consider
throughput, latency, complexity, and failure modes.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Request-scoped is simpler: create, use, dispose. No shared state, no
contention. But it pays the creation cost on every request (TCP
handshake, TLS negotiation, authentication). Pool-scoped amortises
creation cost and caps resource usage, but introduces complexity:
pool sizing, connection health checks, contention under load, and the
risk of returning stale or broken connections.

Choose request-scoped for low-throughput systems (CLI tools, batch
jobs, tests) where simplicity outweighs creation cost. Choose
pool-scoped for servers handling concurrent requests where creation
latency is measurable (>10ms).

*** Q5. Identify the failure modes in this shutdown handler

#+begin_src javascript
process.on('SIGTERM', async () => {
  await database.close()
  await messageQueue.disconnect()
  await cache.flush()
  process.exit(0)
})
#+end_src

What can go wrong? Identify at least three failure modes.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

(1) *No timeout*: if =database.close()= hangs, the remaining
resources are never cleaned up and the process never exits, leading
to a =SIGKILL= from the orchestrator. (2) *Sequential, not parallel*:
the three disposals are independent but awaited in sequence, wasting
the shutdown deadline. Use =Promise.allSettled=. (3) *Error
swallowing*: if =database.close()= throws, subsequent disposals never
run. (4) *Misleading exit code*: =process.exit(0)= indicates
success even if disposal failed.

*** Q6. Analyse the relationship between circuit breakers and resource management

How does a circuit breaker interact with the resource lifecycle?
Consider what happens to already-acquired resources when the breaker
opens.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A circuit breaker guards the /acquisition/ phase — when open, it
prevents new resources from being acquired. Already-acquired resources
are unaffected and still need proper disposal. When the breaker opens
mid-operation, in-flight operations hold their resources normally and
dispose them on completion. The breaker reduces pressure on the
failing downstream by preventing /new/ acquisitions only.

*** Q7. Analyse the =SuppressedError= chain when three resources' disposers all throw

Resources A, B, and C are declared with =using= (in that order).
The body throws, and C's and B's disposers also throw. Describe the
resulting error structure.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Disposal runs in LIFO: C, then B, then A. (1) The body throws
Error X. (2) C's disposer throws Error Y → =SuppressedError { error:
Y, suppressed: X }=. (3) B's disposer throws Error Z → =SuppressedError
{ error: Z, suppressed: <previous SuppressedError> }=. (4) A's
disposer succeeds.

The final error is a nested =SuppressedError=. To find the original
error, follow the =.suppressed= chain to the leaf.

*** Q8. Compare =FinalizationRegistry= with =using= as leak prevention strategies

What are the strengths and weaknesses of each? Can they be
complementary?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=using= is /preventive/: it guarantees disposal by construction,
deterministically at scope exit. =FinalizationRegistry= is
/detective/: it alerts after the fact, non-deterministically when the
GC runs. =using= requires developer opt-in at every call site;
=FinalizationRegistry= can be baked into the resource constructor.

They are complementary: =using= prevents leaks, =FinalizationRegistry=
detects the ones that slip through (missed =using=, third-party code,
unforeseen code paths).

*** Q9. Analyse why pool exhaustion causes cascading failures differently than a crash

Explain the mechanism by which a resource leak in Service A causes
Services C and D to fail, even though the database is healthy.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Service A leaks connections — each request opens a connection that
is never returned. The database's connection slots fill up with
zombie connections. When Service A (or any other service) tries to
open a new connection, it is rejected — not because the database is
down, but because all slots are occupied. Service A starts returning
errors. Services C and D, which depend on A, start failing too. The
database itself is healthy and operational throughout — the problem
is entirely in the connection accounting.

*** Q10. Analyse why idempotent disposal is architecturally important

Should =[Symbol.dispose]()= be safe to call twice? What problems
arise if it is not?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Idempotent disposal is important because: (1) a resource might be
disposed explicitly /and/ by =using= at scope exit — double disposal
should not throw. (2) =DisposableStack= may dispose a resource that
is also tracked by =using=. (3) Defensive error recovery might
dispose proactively.

If disposal is not idempotent, double disposal throws (e.g.
"connection already closed"), which wraps the real error in a
=SuppressedError= and obscures the root cause. The standard pattern
is a =disposed= boolean flag checked at the top of the method.

-----

* Level 5: Evaluate

/Justify decisions, critique designs, defend positions./

*** Q1. Critique per-request connection creation in a production web server

A team uses =using db = createDatabaseConnection()= inside every
HTTP handler. Evaluate this approach for a production server handling
hundreds of requests per second.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

This creates and destroys a connection per request. For a low-traffic
tool, acceptable. For a production server: (1) connection creation is
expensive (TCP + TLS + auth, 5-50ms), adding latency to every
request; (2) under load, simultaneous connections equal concurrent
requests, risking database limit exhaustion; (3) the database bears
constant connection churn.

Recommend a connection pool: create at startup, borrow per request
via =using=, return on scope exit. =using= is still used — but for
the borrow/return cycle, not creation/destruction.

*** Q2. Defend or challenge: "Every class that holds a resource should implement =Symbol.dispose="

Under what circumstances is this statement wrong?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Wrong when: (1) the class /borrows/ a resource via dependency
injection — disposing it would violate the ownership contract; (2)
the resource has process lifetime (singleton logger) — no scope exit
triggers disposal; (3) a DI container or framework manages lifecycle —
adding =Symbol.dispose= creates conflicting cleanup paths.

Refined principle: every class that /owns/ a resource with a shorter
lifetime than the process should implement =Symbol.dispose=.

*** Q3. Evaluate =FinalizationRegistry= as a primary resource management strategy

A developer proposes: "We don't need =using= — let the GC clean up
via =FinalizationRegistry=." Evaluate.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Fundamentally flawed. The GC is non-deterministic: it runs on memory
pressure, not resource need. Connections stay open for minutes or
hours. Under load, connections accumulate faster than the GC reclaims
them. The GC has no knowledge of database connection limits or file
descriptor caps.

=FinalizationRegistry= is a safety net, not a strategy. Relying on
it is like relying on smoke detectors instead of fire prevention.

*** Q4. Justify block scoping over function scoping for =using=

The TC39 committee chose block scoping (like =let=) rather than
function scoping (like Go's =defer=). Was this right?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Block scoping is the superior choice. (1) It matches =let=/=const=
semantics that developers already understand. (2) It enables tighter
lifetimes — a resource in an =if= block is disposed at block end, not
function end. (3) In loops, block scoping disposes per iteration,
preventing accumulation. Go's =defer= requires an IIFE workaround.

Trade-off: developers may be surprised that =using= in one block
doesn't survive into a sibling block. But this is the same surprise
=let= produces, and the ecosystem absorbed it.

*** Q5. Evaluate whether =SuppressedError= nesting is a design flaw

Some argue =AggregateError= (flat list) would be better than nested
=SuppressedError=. Evaluate both designs.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

=SuppressedError= nesting preserves causal ordering: the outermost
=.error= is the most recent failure, following =.suppressed= reaches
the original. This matches LIFO disposal order.

=AggregateError= is easier to iterate but loses causal position.

In practice, multiple disposal failures are rare. The causal chain is
more useful for debugging than a flat list, though tooling must be
updated to traverse it — a real adoption cost.

*** Q6. Critique the design of =using= allowing =null= and =undefined=

The spec says =using x = null= is valid. Is this a good decision?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Enables conditional acquisition (=using db = condition ? create() : null=)
without extra nesting. Pragmatic.

Risk: a function expected to return =Disposable= might return =null=
due to a bug, and =using= silently accepts it. The code fails later
with a confusing null reference error instead of a disposal-related
error. TypeScript's type system mitigates this — if the return type
is =Disposable= (not =Disposable | null=), the compiler catches it.

*** Q7. Evaluate the monitoring strategy: "alert on connections older than 1 hour"

Is this a good SRE alert? When does it produce false positives or
miss real leaks?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

False positives: long-running batch jobs or migration scripts may
legitimately hold connections for hours. False negatives: a leak
that opens and abandons connections every 30 seconds never triggers
this alert — each connection is short-lived, but the total count
grows monotonically.

Better composite strategy: (1) alert on lifetime >1 hour /and/ idle;
(2) alert on total count exceeding pool max percentage; (3) alert on
monotonic growth over a sliding window.

*** Q8. Evaluate this =withLogging= wrapper for =using= declarations

#+begin_src javascript
function withLogging<T extends Disposable>(resource: T, name: string): T {
  console.log(`Acquired: ${name}`)
  const original = resource[Symbol.dispose].bind(resource)
  resource[Symbol.dispose] = () => {
    console.log(`Disposing: ${name}`)
    original()
  }
  return resource
}
#+end_src

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Sound idea (lifecycle observability), flawed implementation. (1)
Mutates the original object — if shared or if the original method is
referenced elsewhere, creates surprising behaviour. (2) Logs
"Disposing" before =original()= runs — misleading if disposal throws.
(3) Does not capture acquisition time for lifetime measurement.

Better: a composition wrapper that delegates without mutating, or
instrumentation at the factory/pool level.

*** Q9. Evaluate whether =using= makes =try/finally= obsolete

Does =using= fully replace =try/finally=?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

No. =using= replaces =try/finally= for resource cleanup, but
=try/finally= has broader uses: (1) non-resource state cleanup
(resetting a flag); (2) cleanup that depends on whether an error
occurred; (3) cleanup of non-object values; (4) APIs that don't
return disposable objects.

=using= is for object-shaped resources with a "close" operation.
=try/finally= remains for all other "ensure this runs on exit"
patterns.

*** Q10. Evaluate: "Connection pooling eliminates the need for =using="

A developer argues that automatic return-on-idle pools make =using=
unnecessary. Assess.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

Return-on-idle reduces leak risk but: (1) the idle timeout delays
return, reducing effective pool capacity; (2) too-short timeouts
reclaim connections mid-use; (3) it masks bugs — developers never
learn to manage resources, leading to problems with non-pooled
resources.

=using= provides deterministic, immediate cleanup. Pool timeouts
provide eventual cleanup as a backstop. The ideal combines both:
borrow with =using= for deterministic return, with pool-level idle
timeout as a safety net.

*** Q11. Evaluate =DisposableStack.move()= as an ownership transfer mechanism

=.move()= transfers ownership by creating a new stack and marking the
original as disposed. Critique this design: what are its strengths,
what could go wrong, and how does it compare to Rust's move semantics?

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

*Strengths:* (1) Solves the factory problem — resources can be
assembled in one scope and owned in another. (2) The original stack
is explicitly marked disposed, preventing double-disposal. (3) Simple
API — one method, no special syntax.

*Weaknesses:* (1) Nothing prevents using the original stack after
=.move()= — calling =.use()= on it throws, but only at runtime.
TypeScript's type system does not track moved-from state. (2) If the
caller forgets to assign the result of =.move()=, all resources are
silently leaked — the original stack is "disposed" (but no disposers
ran), and the new stack is unreachable. (3) Unlike Rust's compile-time
move semantics, JavaScript's =.move()= is a runtime-only convention
with no language enforcement.

*Compared to Rust:* Rust's move semantics are enforced by the
compiler — using a moved-from value is a compile error.
=DisposableStack.move()= is a library-level convention. It solves the
same problem (ownership transfer) but with weaker guarantees.

-----

* Level 6: Create

/Design new solutions, produce original work, synthesise knowledge./

*** Q1. Design a disposable HTTP client with connection reuse

Design a class =HttpClient= that:
- Reuses a persistent HTTP connection for multiple requests
- Implements =Symbol.asyncDispose= for graceful shutdown
- Closes the connection after draining in-flight requests

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should include:
- An in-flight counter incremented before each request, decremented
  in =finally=
- A drain mechanism (Promise + stored resolver) that
  =[Symbol.asyncDispose]= awaits
- Agent/connection destruction after draining

#+begin_src javascript
class HttpClient implements AsyncDisposable {
  private agent: http.Agent
  private inFlightCount = 0
  private drainResolve: (() => void) | null = null

  constructor(private baseUrl: string) {
    this.agent = new http.Agent({ keepAlive: true, maxSockets: 10 })
  }

  async request(path: string): Promise<Response> {
    this.inFlightCount++
    try {
      return await fetch(`${this.baseUrl}${path}`)
    } finally {
      this.inFlightCount--
      if (this.inFlightCount === 0 && this.drainResolve) {
        this.drainResolve()
      }
    }
  }

  async [Symbol.asyncDispose](): Promise<void> {
    if (this.inFlightCount > 0) {
      await new Promise<void>((r) => { this.drainResolve = r })
    }
    this.agent.destroy()
  }
}
#+end_src

*** Q2. Design a resource leak detector for a test suite

Design a utility that fails the test if a resource is not disposed
by the end of the test. It should report which resource leaked and
where it was created.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should include:
- A registry (=Map=) of active resources with creation stack traces
- A =tracked()= wrapper that registers on creation and unregisters
  on disposal
- An =assertNoLeaks()= function called in =afterEach()=

#+begin_src javascript
const active = new Map<string, string>()

function tracked<T extends Disposable>(resource: T, label: string): T {
  const id = `${label}-${Date.now()}`
  active.set(id, new Error().stack ?? 'unknown')

  const original = resource[Symbol.dispose].bind(resource)
  resource[Symbol.dispose] = () => {
    active.delete(id)
    original()
  }
  return resource
}

function assertNoLeaks(): void {
  if (active.size > 0) {
    const leaks = [...active.entries()]
      .map(([id, stack]) => `Leaked: ${id}\n${stack}`)
      .join('\n\n')
    active.clear()
    throw new Error(`Resource leak detected:\n\n${leaks}`)
  }
}
#+end_src

*** Q3. Design a graceful shutdown orchestrator

Design a =ShutdownOrchestrator= class that:
- Registers resources with a priority (critical, normal, low)
- Disposes in priority order on =SIGTERM=
- Enforces a configurable timeout
- Logs progress and errors

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should include:
- A priority enum or union type
- A registration method storing name, disposable, and priority
- An =execute()= method that processes priority groups sequentially,
  resources within each group in parallel via =Promise.allSettled=
- A =setTimeout= guard that force-exits on deadline
- Exit code reflecting success/failure

#+begin_src javascript
type Priority = 'critical' | 'normal' | 'low'

class ShutdownOrchestrator {
  private entries: Array<{
    name: string
    priority: Priority
    disposable: AsyncDisposable | Disposable
  }> = []

  constructor(private timeoutMs = 30_000) {}

  register(
    name: string,
    disposable: AsyncDisposable | Disposable,
    priority: Priority = 'normal'
  ): void {
    this.entries.push({ name, priority, disposable })
  }

  async execute(): Promise<void> {
    const timeout = setTimeout(() => process.exit(1), this.timeoutMs)

    for (const priority of ['critical', 'normal', 'low'] as const) {
      const group = this.entries.filter((e) => e.priority === priority)
      await Promise.allSettled(
        group.map(async (entry) => {
          if (Symbol.asyncDispose in entry.disposable) {
            await entry.disposable[Symbol.asyncDispose]()
          } else {
            (entry.disposable as Disposable)[Symbol.dispose]()
          }
        })
      )
    }

    clearTimeout(timeout)
  }
}
#+end_src

*** Q4. Design a connection pool that returns disposable connections

Design a =ConnectionPool= where =acquire()= returns a disposable
wrapper. Consumers use =using conn = pool.acquire()= and the
connection is automatically *returned to the pool* (not closed) on
scope exit.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should include:
- A =PooledConnection= wrapper implementing =Disposable= that
  returns (not closes) the inner connection on disposal
- Idempotent disposal (=returned= flag)
- A =ConnectionPool= with =acquire()= and =AsyncDisposable= for
  final shutdown

#+begin_src javascript
class PooledConnection implements Disposable {
  private returned = false

  constructor(
    readonly inner: DatabaseSync,
    private returnFn: (conn: DatabaseSync) => void
  ) {}

  [Symbol.dispose](): void {
    if (!this.returned) {
      this.returned = true
      this.returnFn(this.inner)
    }
  }
}

class ConnectionPool implements AsyncDisposable {
  private available: DatabaseSync[] = []
  private inUse = new Set<DatabaseSync>()

  constructor(private factory: () => DatabaseSync, private max: number) {}

  acquire(): PooledConnection {
    const raw = this.available.pop() ?? this.factory()
    this.inUse.add(raw)
    return new PooledConnection(raw, (conn) => {
      this.inUse.delete(conn)
      this.available.push(conn)
    })
  }

  async [Symbol.asyncDispose](): Promise<void> {
    for (const c of [...this.available, ...this.inUse]) c.close()
  }
}
#+end_src

*** Q5. Design a multi-layer resource management architecture

Design the resource architecture for a web application with:
- A PostgreSQL connection pool (application-scoped)
- A Redis cache client (application-scoped)
- Per-request database transactions
- Per-request temporary files for uploads

Show which ownership model each uses, how they compose, and how they
are cleaned up. Include a diagram.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should:
- Use pool ownership for the database and container ownership for
  Redis (both application-scoped, both =AsyncDisposable=)
- Use lexical ownership for per-request resources (=using=)
- Show the nesting: application scope contains request scopes
- Include a =SIGTERM= path that drains the outer resources

#+begin_example
  Application Startup
  ┌────────────────────────────────────────────────────┐
  │  APPLICATION-SCOPED                               │
  │  await using pgPool = new PgPool({ max: 20 })    │
  │  await using redis  = new RedisClient()           │
  │                                                    │
  │  Per-Request Handler                               │
  │  ┌────────────────────────────────────────────────┐│
  │  │  REQUEST-SCOPED                               ││
  │  │  using conn = pgPool.acquire()                ││
  │  │  using tx   = conn.beginTransaction()         ││
  │  │  using file = TempFile.create()               ││
  │  │  // On exit: file → tx → conn (LIFO)          ││
  │  └────────────────────────────────────────────────┘│
  │                                                    │
  │  SIGTERM → drain pool, disconnect Redis            │
  └────────────────────────────────────────────────────┘
#+end_example

*** Q6. Create a teaching analogy for =using=, LIFO disposal, and =SuppressedError=

Write a non-technical analogy that explains all three concepts to
someone with no programming background. The analogy should be precise
enough that each concept maps cleanly.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good analogy should have three distinct mappings — one per concept —
and not break down when examined closely. Example:

*The Library Study Room*: You check out a textbook, then a
calculator, then headphones from the library desk. The checkout rule
(=using=) means everything is automatically returned when you leave
the room — you cannot forget. You return items in reverse order
(LIFO): headphones first (on top of everything else), then calculator,
then textbook. If you spilled coffee on the textbook (body error)
/and/ the headphones have a broken ear pad (disposal error), the
librarian's damage report (=SuppressedError=) records /both/ — with
the old system (=try/finally=), only the ear pad would be recorded
and the coffee stain would be forgotten.

*** Q7. Design a resource-aware request context

Design a =RequestContext= class where handlers register resources
during request processing, and all registered resources are disposed
when the request ends. Support both sync and async disposables.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should:
- Use =AsyncDisposableStack= internally
- Provide =track()= for sync and =trackAsync()= for async resources
- Provide =defer()= for arbitrary cleanup functions
- Be used via =await using ctx = new RequestContext()= in middleware

#+begin_src javascript
class RequestContext implements AsyncDisposable {
  private stack = new AsyncDisposableStack()

  track<T extends Disposable>(resource: T): T {
    this.stack.use(resource)
    return resource
  }

  trackAsync<T extends AsyncDisposable>(resource: T): T {
    this.stack.use(resource)
    return resource
  }

  defer(fn: () => void | Promise<void>): void {
    this.stack.defer(async () => { await fn() })
  }

  async [Symbol.asyncDispose](): Promise<void> {
    await this.stack[Symbol.asyncDispose]()
  }
}
#+end_src

*** Q8. Design a test that verifies LIFO disposal ordering

Write a test (using Vitest) that proves three resources are disposed
in correct LIFO order. The test should fail if the order is wrong.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good test should:
- Use a shared log array that records acquisition and disposal events
- Create three =using= resources in a bare block
- Assert the exact event sequence after the block exits

#+begin_src javascript
class OrderTracker implements Disposable {
  constructor(private name: string, private log: string[]) {
    this.log.push(`acquire:${name}`)
  }

  [Symbol.dispose](): void {
    this.log.push(`dispose:${this.name}`)
  }
}

it('disposes in LIFO order', () => {
  const log: string[] = []
  {
    using a = new OrderTracker('A', log)
    using b = new OrderTracker('B', log)
    using c = new OrderTracker('C', log)
  }
  expect(log).toEqual([
    'acquire:A', 'acquire:B', 'acquire:C',
    'dispose:C', 'dispose:B', 'dispose:A',
  ])
})
#+end_src

*** Q9. Create a diagnostic dashboard specification for resource health

Specify the panels, metrics, and alerts for a monitoring dashboard
that gives an SRE team visibility into resource management health
for a Node.js web application.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good specification should include at least:

- *Connection pool gauge*: active vs idle vs max
- *Lifecycle histograms*: acquisition latency and connection lifetime
  at p50/p95/p99
- *Error counters*: disposal errors, =SuppressedError= occurrences,
  pool exhaustion events
- *System gauges*: open file descriptors vs ulimit
- *Leak indicators*: =FinalizationRegistry= callbacks, long-lived
  idle connections

Alerts with severity:
| Condition                          | Severity |
|------------------------------------+----------|
| active > 80% of max for > 2 min   | Warning  |
| acquisition failure rate > 0       | Critical |
| open FDs > 90% of ulimit          | Critical |
| FinalizationRegistry callback      | Warning  |

*** Q10. Design a =Disposable= class whose disposal depends on its current state

Create a =Transaction= class that auto-rolls back on disposal if
not committed, and is a no-op if already committed. Include starter
code for the reader and the full solution.

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

*Starter code:*

#+begin_src javascript
class Transaction implements Disposable {
  // TODO: track whether committed.

  constructor(private db: DatabaseSync) {
    // TODO: begin the transaction.
  }

  commit(): void {
    // TODO: commit and update state.
  }

  [Symbol.dispose](): void {
    // TODO: roll back if not committed.
  }
}
#+end_src

*Solution:*

#+begin_src javascript
class Transaction implements Disposable {
  private committed = false

  constructor(private db: DatabaseSync) {
    this.db.exec('BEGIN TRANSACTION')
  }

  commit(): void {
    this.db.exec('COMMIT')
    this.committed = true
  }

  [Symbol.dispose](): void {
    if (!this.committed) {
      this.db.exec('ROLLBACK')
    }
  }
}
#+end_src

Key insight: =[Symbol.dispose]= does not always mean "close." It
means "ensure a safe final state." For a transaction, that is either
committed or rolled back — never left hanging.

*** Q11. Design a composition root using =AsyncDisposableStack=

Design a =createApp()= function that assembles an application from
multiple resources: a database pool, a cache client (non-disposable,
has a =.quit()= method), an HTTP server, and a service discovery
registration (cleanup is a deregistration call). The function should:

- Register resources in dependency order
- Handle both disposable and non-disposable resources
- Transfer ownership to the caller
- Ensure correct teardown order on shutdown

**** Answer
:PROPERTIES:
:VISIBILITY: folded
:END:

A good design should include:

#+begin_src javascript
async function createApp(config: AppConfig): Promise<AsyncDisposableStack> {
  await using stack = new AsyncDisposableStack()

  // 1. Database pool — implements AsyncDisposable.
  const pool = stack.use(new AsyncDatabasePool(config.dbUrl))

  // 2. Cache client — non-disposable, custom cleanup.
  const cache = stack.adopt(
    createRedisClient(config.redisUrl),
    async (client) => { await client.quit() }
  )

  // 3. HTTP server — implements AsyncDisposable.
  const server = stack.use(createHttpServer({ pool, cache }))

  // 4. Service discovery — no resource, just a cleanup action.
  await registerWithServiceDiscovery(config.serviceName)
  stack.defer(async () => {
    await deregisterFromServiceDiscovery(config.serviceName)
  })

  // Transfer ownership to the caller.
  return stack.move()
}

// main.ts
async function main(): Promise<void> {
  await using app = await createApp(loadConfig())
  // App runs until SIGTERM triggers scope exit.
  // Teardown order (LIFO):
  //   1. Deregister from service discovery (defer, registered 4th)
  //   2. Close HTTP server (use, registered 3rd)
  //   3. Quit cache client (adopt, registered 2nd)
  //   4. Drain database pool (use, registered 1st)
}
#+end_src

Key design decisions: (1) dependency order registration ensures LIFO
teardown respects dependencies — the server shuts down before the pool
it depends on; (2) =.adopt()= handles Redis without requiring a
wrapper class; (3) =.defer()= handles the service discovery side
effect; (4) =.move()= transfers everything to the caller's scope.

-----

* Summary

This assessment tested understanding across six cognitive levels:

- *Remember* (L1): recall the building blocks — symbols, ordering,
  error types, configuration
- *Understand* (L2): explain /why/ things work the way they do —
  LIFO rationale, ownership semantics, SRE implications
- *Apply* (L3): write code using =using=, =DisposableStack=,
  =SuppressedError= handling, shutdown hooks
- *Analyse* (L4): compare approaches (=using= vs =defer=, pool vs
  request-scoped), identify failure modes, trace error chains
- *Evaluate* (L5): critique designs, defend decisions, assess
  trade-offs in real architectural choices
- *Create* (L6): design original systems — pools, orchestrators,
  dashboards, test utilities

-----

* Related Documents

- [[./teaching_explicit_resource_management.org][Explicit Resource Management: =using= and =await using=]] — Learn the mechanics
- [[./teaching_resource_management_architecture.org][Going Deeper: Resource Management in Architecture and Operations]] — Broaden to architecture and SRE
- [[./teachingStyleguide.org][Teaching Document Style Guide]] — How teaching documents are structured

-----

*Questions or suggestions?* File an issue or submit a PR to improve this guide!
