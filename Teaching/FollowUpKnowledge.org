#+title: Going Deeper: Resource Management in Architecture and Operations
#+author: Claude Code
#+date: [2026-02-21]
#+OPTIONS: toc:3
#+startup: indent

*Prerequisite*: [[./teaching_explicit_resource_management.org][Explicit Resource Management: =using= and =await using=]]

-----

* Table of Contents                                                     :TOC:
(Auto-generated by Org-mode on export via =#+OPTIONS: toc:3=)

-----

* Introduction

The teaching document on =using= and =await using= covered the
mechanics: syntax, scope rules, disposal order, =SuppressedError=.
You now know /how/ to use explicit resource management in TypeScript.

This document asks a different set of questions:

- *Where does this fit?* — How does =using= relate to broader
  patterns in software architecture?
- *What happens at scale?* — What does resource management look like
  when your code runs on hundreds of servers, under load, for months?

We broaden the lens from a single language feature to a discipline
that spans architecture, reliability engineering, and system design.

To test and deepen your understanding, see the companion document:
[[./teaching_resource_management_assessment.org][Resource Management Assessment: Bloom's Taxonomy]]

-----

* Resource Management as an Architectural Concern

** The RAII Principle

=using= did not invent automatic resource cleanup — it brought an
established pattern to JavaScript. The pattern is called *RAII*:
Resource Acquisition Is Initialisation. It originated in C++ in the
1980s and is the foundation of resource management in Rust, C#, Python
(=with= statement), and now JavaScript.

The principle is simple:

#+begin_quote
*Tie the lifetime of a resource to the lifetime of an object or
scope.* Acquisition happens at creation; release happens at
destruction.
#+end_quote

Different languages express RAII differently:

| Language   | Mechanism               | Cleanup trigger              |
|------------+-------------------------+------------------------------|
| C++        | Destructors             | Object goes out of scope     |
| Rust       | =Drop= trait            | Owner goes out of scope      |
| Python     | =with= / =__exit__=     | Block exits                  |
| C#         | =using= / =IDisposable= | Block exits                  |
| Go         | =defer=                 | Function returns             |
| JavaScript | =using= / =Symbol.dispose= | Block exits               |

The architectural insight is that *resource management is not a
language feature problem — it is an ownership problem*. Who owns the
resource? When does ownership end? The language feature is just the
mechanism that enforces the answer.

** Ownership and Lifetime Models

When you architect a system, every resource must have a clear owner.
There are three common ownership models:

*** 1. Lexical ownership (scope-bound)

The resource lives exactly as long as the code block that created it.
This is what =using= provides — and what our codebase uses today.

In =src/lib/db.test.ts=, the test acquires and disposes a connection
within a single =it= block:

#+begin_src typescript
// src/lib/db.test.ts — lexical ownership in practice.
it('creates DatabaseSync instance with DATABASE_PATH', () => {
  vi.stubEnv('DATABASE_PATH', ':memory:')
  using connection = createDatabaseConnection()
  expect(connection).toBeDefined()
})
// connection.close() fires here automatically.
#+end_src

Best for: short-lived, request-scoped resources. Database connections
in a CLI tool. File handles for a single operation. This is where our
codebase sits today.

*** 2. Container ownership (lifecycle-bound)

The resource lives as long as its container — a class, a module, a
service. The container is responsible for cleanup.

If our codebase grew a =BookService= class, the database connection
would be container-owned:

#+begin_src typescript
class BookService implements Disposable {
  private db: DatabaseSync

  constructor(dbPath: string) {
    this.db = new DatabaseSync(dbPath)  // owned by BookService
  }

  findAll(): Book[] {
    return this.db.prepare('SELECT * FROM books').all() as Book[]
  }

  [Symbol.dispose](): void {
    this.db.close()  // cleaned up when BookService is disposed
  }
}
#+end_src

Best for: resources that are expensive to create and should be
reused across multiple operations within a logical unit.

*** 3. Pool ownership (shared)

No single consumer owns the resource. A pool creates, lends, and
reclaims resources. Consumers borrow and return them.

#+begin_src typescript
class ConnectionPool implements AsyncDisposable {
  private available: DatabaseSync[] = []
  private inUse: Set<DatabaseSync> = new Set()

  acquire(): DatabaseSync {
    const conn = this.available.pop() ?? this.createNew()
    this.inUse.add(conn)
    return conn
  }

  release(conn: DatabaseSync): void {
    this.inUse.delete(conn)
    this.available.push(conn)
  }

  async [Symbol.asyncDispose](): Promise<void> {
    for (const conn of [...this.available, ...this.inUse]) {
      conn.close()
    }
  }
}
#+end_src

Best for: high-throughput systems where creating a resource per
request is too expensive (database connection pools, thread pools,
HTTP connection pools).

*** How our codebase would evolve

Our current pattern — =using db = createDatabaseConnection()= per
operation — is lexical ownership. This is ideal for a CLI tool. If
the project grew into a server handling concurrent requests, the
progression would be:

#+begin_example
OWNERSHIP EVOLUTION

  CLI tool (now)              Service (future)           High-traffic server
  ┌──────────────┐            ┌──────────────┐           ┌──────────────┐
  │   Lexical    │            │  Container   │           │    Pool      │
  │              │            │              │           │              │
  │ using db =   │   ──▶      │ class Svc {  │   ──▶     │ pool.acquire │
  │   create()   │            │   db: DB     │           │ using conn = │
  │ // per call  │            │ }            │           │ // borrow    │
  └──────────────┘            └──────────────┘           └──────────────┘
      Simple                    Reuse within              Reuse across
      No concurrency            a logical unit            concurrent requests
#+end_example

** The Dependency Inversion Angle

In a well-architected system, components do not create their own
resources — they /receive/ them. This is *dependency injection*, and
it has a direct impact on resource management:

#+begin_example
WITHOUT dependency injection:
┌────────────────────────────────────────┐
│  BookService                           │
│  ┌──────────────────────────────────┐  │
│  │ creates its own DB conn          │  │  ← BookService owns the resource
│  │ must close it itself             │  │  ← BookService must manage cleanup
│  └──────────────────────────────────┘  │
└────────────────────────────────────────┘

WITH dependency injection:
┌────────────────────────────────────────┐
│  Composition Root                      │
│  ┌──────────────────────────────────┐  │
│  │ creates DB conn                  │  │  ← Root owns the resource
│  │ passes it to BookService         │  │
│  │ disposes it at shutdown          │  │  ← Root manages cleanup
│  └──────────────────────────────────┘  │
│           │                            │
│           ▼                            │
│  ┌──────────────────────────────────┐  │
│  │ BookService                      │  │
│  │ uses DB conn (borrower)          │  │  ← BookService is a borrower
│  │ never closes it                  │  │  ← No cleanup responsibility
│  └──────────────────────────────────┘  │
└────────────────────────────────────────┘
#+end_example

This separation of /who creates/ from /who uses/ is fundamental. When
a component both creates and uses a resource, two concerns are
entangled. When creation is lifted to a composition root, resource
lifetime becomes a top-level architectural decision.

** Resource Lifecycle Patterns

Beyond individual scopes, resources follow lifecycle patterns at the
system level:

#+begin_example
REQUEST-SCOPED                    APPLICATION-SCOPED
(per HTTP request)                (singleton for app lifetime)

  Request arrives                   App starts
       │                                │
       ▼                                ▼
  Acquire resource                 Acquire resource
       │                                │
       ▼                                ▼
  Handle request                   Serve requests (hours/days)
       │                                │
       ▼                                ▼
  Dispose resource                 SIGTERM received
       │                                │
       ▼                                ▼
  Response sent                    Graceful shutdown
                                        │
                                        ▼
                                   Dispose resource
#+end_example

=using= maps naturally to request-scoped resources. Application-scoped
resources require a different strategy — typically a shutdown hook
(=process.on('SIGTERM', ...)=) or a framework-level lifecycle
manager.

** =DisposableStack= as an Architectural Building Block

The ownership models above — container and pool — both face the same
structural problem: a single owner manages /multiple/ resources whose
count may vary at runtime. A =BookService= might hold a database
connection and a cache client. A composition root might assemble a
database pool, an HTTP server, and a metrics exporter. The number and
types of resources are determined by configuration, not by source
code.

=DisposableStack= is the mechanism that makes this work. It acts as a
*resource registry*: components register their resources at creation
time, and the stack handles LIFO disposal of everything on teardown.

*** Composition Roots with =DisposableStack=

The dependency injection pattern shown above becomes concrete with
=DisposableStack=:

#+begin_src typescript
// Composition root: assembles all application resources.
function createApp(config: AppConfig): DisposableStack {
  using stack = new DisposableStack()

  // Application-scoped resources, registered in dependency order.
  const db = stack.use(new DatabaseSync(config.dbPath))
  const cache = stack.adopt(
    createRedisClient(config.redisUrl),
    (client) => client.quit()
  )

  // Services receive resources as borrowers — no cleanup responsibility.
  const bookService = new BookService(db, cache)
  const server = stack.use(createHttpServer(bookService))

  // Transfer ownership to the caller (main function or shutdown handler).
  return stack.move()
}
#+end_src

The composition root:
1. Creates resources in dependency order (database before services)
2. Registers each with the stack for automatic cleanup
3. Uses =.move()= to transfer ownership to the caller
4. On disposal, everything tears down in reverse order

*** =DisposableStack= in Graceful Shutdown

Application-scoped resources cannot use lexical =using= — their
lifetime spans the entire process. =DisposableStack= bridges this gap
by collecting all application resources and disposing them on
=SIGTERM=:

#+begin_src typescript
async function main(): Promise<void> {
  await using app = new AsyncDisposableStack()

  const pool = app.use(new AsyncDatabasePool(config))
  const server = app.use(createHttpServer(pool))

  // Register a non-disposable cleanup action.
  app.defer(() => deregisterFromServiceDiscovery())

  // Block until SIGTERM.
  await server.listen(3000)
  // On SIGTERM: deregister → server closed → pool drained (LIFO).
}
#+end_src

Without =DisposableStack=, the shutdown handler would need a manual
list of resources and a hand-written disposal loop — the same
error-prone pattern that =using= eliminated at the block level.

#+begin_example
DISPOSABLE STACK IN ARCHITECTURE

  ┌─────────────────────────────────────────────────┐
  │              Composition Root                   │
  │                                                 │
  │   await using app = new AsyncDisposableStack()  │
  │                                                 │
  │   app.use(pool)         ← registered 1st        │
  │   app.use(server)       ← registered 2nd        │
  │   app.defer(cleanup)    ← registered 3rd        │
  │                                                 │
  │   On SIGTERM disposal:                          │
  │     cleanup()  → server.close()  → pool.drain() │
  │     (3rd)        (2nd)             (1st)         │
  └─────────────────────────────────────────────────┘
#+end_example

This pattern scales naturally: adding a new resource to the
application means one =app.use()= call. The disposal order is
automatically correct (LIFO), and if any disposer throws, the
remaining disposers still run.

-----

* Resource Management as an SRE Concern

** What Goes Wrong at Scale

In a development environment, forgetting to close a database
connection means a warning in a log. In production, it means:

- *Connection exhaustion*: PostgreSQL defaults to 100 connections. A
  leak of 1 connection per request exhausts the pool in 100 requests.
  The 101st request hangs or fails. Every request after that fails.
  The database is unreachable — not because it is down, but because
  all its connection slots are occupied by abandoned connections.

- *File descriptor exhaustion*: Linux defaults to 1024 open file
  descriptors per process. Leaked file handles accumulate silently
  until the process cannot open new files, sockets, or pipes. The
  error message (=EMFILE: too many open files=) is cryptic and the
  root cause is far from the symptom.

- *Memory pressure*: Each unclosed resource holds memory —
  buffers, caches, internal state. Thousands of leaked resources
  create steady memory growth that looks like a memory leak in
  profiling tools, eventually triggering OOM kills.

- *Cascading failures*: When service A exhausts its connection pool
  to database B, service A starts failing. Services C and D, which
  depend on A, start failing too. A single resource leak in one
  component cascades across the system.

#+begin_example
CASCADING FAILURE FROM A CONNECTION LEAK

  Service A                    Database B
  ┌──────────┐                ┌──────────┐
  │ Leak:    │───conn 1───▶   │ max: 100 │
  │ 1 conn   │───conn 2───▶   │          │
  │ per req  │───conn 3───▶   │ slots    │
  │          │    ...          │ filling  │
  │          │───conn 100──▶  │ FULL     │
  │          │───conn 101──▶  │ REJECTED │
  └──────────┘                └──────────┘
       │
       ▼ A starts failing
  ┌──────────┐  ┌──────────┐
  │Service C │  │Service D │
  │ depends  │  │ depends  │
  │ on A     │  │ on A     │
  │ FAILING  │  │ FAILING  │
  └──────────┘  └──────────┘
#+end_example

** Observability for Resource Management

You cannot fix what you cannot see. SRE practice demands
observability into resource usage:

*Key metrics to instrument:*

| Metric                          | What it reveals                     | Alert threshold                 |
|---------------------------------+-------------------------------------+---------------------------------|
| Open connections (gauge)        | Current resource pressure           | > 80% of pool max               |
| Connection acquisition time     | Pool contention                     | p99 > 500ms                     |
| Connection lifetime             | Potential leaks (very long-lived)   | Any connection > 1 hour         |
| Disposal errors (counter)       | Cleanup failures                    | Any non-zero rate               |
| =SuppressedError= occurrences   | Disposal masking real errors        | Any occurrence (investigate)    |

*What to log on disposal failure:*

#+begin_src typescript
class InstrumentedConnection implements Disposable {
  private acquiredAt: number
  private stack: string

  constructor(private db: DatabaseSync) {
    this.acquiredAt = Date.now()
    this.stack = new Error().stack ?? 'unknown'  // capture creation site
  }

  [Symbol.dispose](): void {
    const lifetimeMs = Date.now() - this.acquiredAt
    if (lifetimeMs > 60_000) {
      console.warn(
        `Long-lived connection (${lifetimeMs}ms). Acquired at:\n${this.stack}`
      )
    }
    this.db.close()
  }
}
#+end_src

Capturing the stack trace at acquisition time is critical — when a
leak is detected, you need to know /where/ the resource was created,
not where the detection happened.

** Graceful Shutdown

When a process receives =SIGTERM= (the standard shutdown signal),
it must release all resources before exiting. This is the SRE
equivalent of =using= at the process level.

#+begin_example
GRACEFUL SHUTDOWN SEQUENCE

  SIGTERM received
       │
       ▼
  Stop accepting new requests
       │
       ▼
  Wait for in-flight requests to complete (with timeout)
       │
       ▼
  Dispose application-scoped resources
  ├── Close database connection pools
  ├── Flush log buffers
  ├── Deregister from service discovery
  └── Close message queue consumers
       │
       ▼
  Exit process
#+end_example

A graceful shutdown handler must address three concerns that
=using= handles automatically at the block level but that require
explicit design at the process level:

1. *Timeout*: if any disposal hangs, the remaining resources are
   never cleaned up. A hard timeout (matching the orchestrator's
   grace period) ensures the process exits.
2. *Parallelism*: independent resources can be disposed concurrently
   using =Promise.allSettled= to avoid wasting the timeout window.
3. *Error isolation*: if one disposal throws, the others must still
   run. Sequential =await= without =try/catch= aborts the chain.

** Circuit Breakers and Resource Exhaustion

When a downstream resource (database, API, file system) becomes
unavailable, a naive system keeps trying to acquire connections —
filling the pool with broken connections and compounding the failure.

A *circuit breaker* detects repeated acquisition failures and
short-circuits future attempts for a cooldown period:

#+begin_example
CIRCUIT BREAKER STATES

  ┌────────┐  failures > threshold  ┌────────┐
  │ CLOSED │───────────────────────▶│  OPEN  │
  │(normal)│                        │(reject)│
  └────────┘                        └───┬────┘
       ▲                                │
       │  success                       │ cooldown expires
       │                                ▼
       │                          ┌──────────┐
       └──────────────────────────│HALF-OPEN │
                                  │(test one)│
                                  └──────────┘
#+end_example

This is not a JavaScript feature — it is an architectural pattern.
But it interacts directly with resource management: the circuit
breaker decides whether to even /attempt/ resource acquisition, and
when it does, the acquired resource still needs proper disposal.

** Leak Detection in Production

Even with =using=, leaks can happen — a resource might be created
outside a =using= scope, or a third-party library might not implement
=Symbol.dispose=. SRE teams deploy leak detection:

- *FinalizationRegistry*: JavaScript's built-in mechanism to detect
  when an object is garbage-collected. If a resource is collected
  without disposal, the registry callback fires.

#+begin_src typescript
// Leak detection using FinalizationRegistry.
const leakDetector = new FinalizationRegistry((description: string) => {
  console.error(`RESOURCE LEAK DETECTED: ${description} was garbage-collected without disposal`)
})

class TrackedConnection implements Disposable {
  private disposed = false

  constructor(private db: DatabaseSync, description: string) {
    leakDetector.register(this, description, this)  // weak ref to self
  }

  [Symbol.dispose](): void {
    if (!this.disposed) {
      this.disposed = true
      leakDetector.unregister(this)  // cancel the leak alarm
      this.db.close()
    }
  }
}
#+end_src

- *Periodic audits*: Scheduled checks that compare expected resource
  counts (e.g. pool size) against actual OS-level resource counts
  (open file descriptors, TCP connections).

- *Load testing*: Sustained load tests that run for hours, monitoring
  resource counts for monotonic growth — the signature of a leak.

-----

* Summary

** Key Takeaways

1. =using= implements the *RAII principle* — a pattern that spans
   C++, Rust, Python, C#, Go, and now JavaScript.
2. Resource management is an *ownership problem*. Three ownership
   models — lexical, container, pool — each suit different
   architectural contexts.
3. *Dependency injection* separates resource creation from usage,
   making lifetime management a top-level architectural decision.
4. =DisposableStack= is the *architectural glue* that enables
   container ownership, composition roots, and graceful shutdown with
   dynamic resource sets.
5. At scale, resource leaks cause *connection exhaustion*, *file
   descriptor exhaustion*, *memory pressure*, and *cascading failures*.
6. SRE practice demands *observability* into resource usage: gauges,
   lifetime histograms, disposal error counters.
7. *Graceful shutdown* is the process-level equivalent of =using= —
   it must be timeout-bounded, parallel, and error-isolated.
8. *Circuit breakers* and *leak detection* (=FinalizationRegistry=)
   are complementary defences against resource exhaustion.

** Quick Reference

| Architectural context | Ownership model | Cleanup mechanism                     |
|-----------------------+-----------------+---------------------------------------|
| CLI tool, single op   | Lexical         | =using= (block scope)                 |
| Service class         | Container       | =Symbol.dispose= on the class         |
| HTTP server           | Pool            | Borrow/return + pool shutdown          |
| Composition root      | Multi-resource  | =DisposableStack= + =.move()=         |
| Application lifetime  | Process-level   | =AsyncDisposableStack= + =SIGTERM=    |

-----

* Related Documents

- [[./teaching_explicit_resource_management.org][Explicit Resource Management: =using= and =await using=]] — The prerequisite teaching document
- [[./teaching_resource_management_assessment.org][Resource Management Assessment]] — 60 questions across Bloom's taxonomy levels
- [[./teachingStyleguide.org][Teaching Document Style Guide]] — How teaching documents are structured

-----

* Further Reading

- [[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization][RAII — Wikipedia]] — History and cross-language perspective
- [[https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html][Rust Ownership — The Rust Programming Language]] — The most rigorous ownership model
- [[https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose][IDisposable — .NET Documentation]] — C#'s equivalent pattern
- [[https://sre.google/sre-book/table-of-contents/][Site Reliability Engineering — Google]] — SRE principles including resource management
- [[https://martinfowler.com/bliki/CircuitBreaker.html][Circuit Breaker — Martin Fowler]] — The circuit breaker pattern

-----

*Questions or suggestions?* File an issue or submit a PR to improve this guide!
