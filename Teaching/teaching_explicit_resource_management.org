#+title: Explicit Resource Management: =using= and =await using=
#+author: Claude Code
#+date: 2026-02-20
#+OPTIONS: toc:3

*Example Sources*:
- =src/lib/db.ts= — synchronous SQLite connection using =DatabaseSync=
- =src/lib/db.test.ts= — test suite using =using= for automatic connection cleanup

-----

* Table of Contents                                                     :TOC:
(Auto-generated by Org-mode on export via =#+OPTIONS: toc:3=)

-----

* Introduction: The Resource Leak Problem

Every program acquires resources — database connections, file handles,
network sockets, locks, timers. Every resource that is acquired must
eventually be released. Fail to release them and you leak memory,
exhaust connection pools, or leave files locked.

JavaScript has never had a built-in mechanism for guaranteed resource
cleanup. Until now.

The *TC39 Explicit Resource Management proposal* (Stage 4, shipping in
Node 22+ and TypeScript 5.2+) introduces two new declarations:

- =using= — for resources with *synchronous* cleanup (=Symbol.dispose=)
- =await using= — for resources with *asynchronous* cleanup (=Symbol.asyncDispose=)

Both tie a resource's lifetime to its *lexical scope*. When the scope
exits — whether by normal completion, =return=, =throw=, or =break= —
the runtime calls the disposal method automatically. No =try/finally=
required. No chance of forgetting.

#+begin_quote
*The core promise:* a resource declared with =using= will always be
cleaned up when its scope exits, no matter what.
#+end_quote

-----

* The Problem: Why =try/finally= Falls Short

** The Manual Cleanup Pattern

Before =using=, the standard approach for guaranteed cleanup was
=try/finally=:

#+begin_src typescript
// ❌ BEFORE — manual cleanup with try/finally
import { createDatabaseConnection } from '#/lib/db'

function runQuery(): Row {
  const db = createDatabaseConnection()
  try {
    return db.prepare('SELECT * FROM books LIMIT 1').get() as Row
  } finally {
    db.close()  // must not forget this
  }
}
#+end_src

This works — but it has four compounding problems.

** Problem 1: Easy to Forget

The =finally= block is optional. A developer in a hurry writes this:

#+begin_src typescript
// ❌ BAD — no cleanup: connection leaks every time this function is called
function runQuery(): Row {
  const db = createDatabaseConnection()
  return db.prepare('SELECT * FROM books LIMIT 1').get() as Row
}
#+end_src

No compiler error. No warning. The connection leaks silently.

** Problem 2: Multiple Resources Nest Badly

Add a second resource and the code becomes a pyramid:

#+begin_src typescript
// ❌ BAD — nesting grows with every additional resource
function exportData(): void {
  const db = createDatabaseConnection()
  try {
    const file = openOutputFile('./export.csv')
    try {
      const lock = acquireLock('export')
      try {
        writeExport(db, file, lock)
      } finally {
        lock.release()
      }
    } finally {
      file.close()
    }
  } finally {
    db.close()
  }
}
#+end_src

Three resources → three nested =try/finally= blocks. This is not
hypothetical: any real application touches multiple resources at once.

** Problem 3: Errors During Cleanup Are Swallowed

If =writeExport= throws *and* =file.close()= also throws, the original
error from =writeExport= is lost:

#+begin_src typescript
try {
  writeExport(db, file, lock)     // throws Error("disk full")
} finally {
  file.close()                     // also throws Error("file already closed")
  // The "disk full" error is now gone — only "file already closed" surfaces
}
#+end_src

The error you actually care about — why did the operation fail? — is
silently replaced by the cleanup error.

** Problem 4: Early Returns Break Naive Patterns

Without =try/finally=, an early =return= skips cleanup entirely:

#+begin_src typescript
// ❌ BAD — db leaks when the early return fires
function findBook(id: number): Book | null {
  const db = createDatabaseConnection()
  if (!isValidId(id)) return null  // db.close() never called
  const row = db.prepare('SELECT * FROM books WHERE id = ?').get(id)
  db.close()
  return row as Book | null
}
#+end_src

-----

* Real-World Example: Our Database Connection

In =src/lib/db.ts=, we open a =DatabaseSync= connection and return it:

#+begin_src typescript
// src/lib/db.ts
import { DatabaseSync } from 'node:sqlite'

export function createDatabaseConnection(): DatabaseSync {
  const databasePath = process.env.DATABASE_PATH

  if (!databasePath) {
    throw new Error(
      'DATABASE_PATH environment variable is required. ' +
        'Please set it using: npx dotenvx set DATABASE_PATH ./data/books.db'
    )
  }

  return new DatabaseSync(databasePath)
}
#+end_src

And in =src/lib/db.test.ts=, we use =using= to manage the connection:

#+begin_src typescript
// src/lib/db.test.ts
import { afterEach, vi } from 'vitest'
import { createDatabaseConnection } from './db'

describe('database connection', () => {
  afterEach(() => {
    vi.unstubAllEnvs()
  })

  it('creates DatabaseSync instance with DATABASE_PATH', () => {
    vi.stubEnv('DATABASE_PATH', ':memory:')

    // ✅ using — connection is closed automatically when this block exits
    using connection = createDatabaseConnection()
    expect(connection).toBeDefined()
    expect(connection.constructor.name).toBe('DatabaseSync')
  })
})
#+end_src

=DatabaseSync= implements =Symbol.dispose= natively (it calls
=db.close()= internally), so no boilerplate is required on our side.
The connection opens at the =using= declaration and closes the instant
the =it= block exits — even if an assertion throws.

-----

* Deep Explanation

** How =using= Works Under the Hood

When the TypeScript compiler sees a =using= declaration, it transforms
it into a =try/finally= block — but one that handles errors from
multiple disposers correctly. This is the conceptual equivalent of what
the compiler generates:

#+begin_src typescript
// What you write:
{
  using db = createDatabaseConnection()
  doWork(db)
}

// What the compiler generates (conceptually):
{
  const db = createDatabaseConnection()
  const __disposer = db[Symbol.dispose].bind(db)
  try {
    doWork(db)
  } finally {
    __disposer()
  }
}
#+end_src

The difference from writing =try/finally= yourself: the compiler
generates this *always*, for every =using= declaration, with no chance
of omission.

** The =Symbol.dispose= Contract

For an object to work with =using=, it must expose a =Symbol.dispose=
method. This is the *disposable interface*:

#+begin_src typescript
// The interface a synchronous disposable must satisfy
interface Disposable {
  [Symbol.dispose](): void
}

// The interface an async disposable must satisfy
interface AsyncDisposable {
  [Symbol.asyncDispose](): Promise<void>
}
#+end_src

You can implement it on any class in one line:

#+begin_src typescript
class DatabaseConnection {
  private db: DatabaseSync

  constructor(path: string) {
    this.db = new DatabaseSync(path)
  }

  prepare(sql: string) {
    return this.db.prepare(sql)
  }

  // Makes this class compatible with `using`
  [Symbol.dispose](): void {
    this.db.close()
  }
}
#+end_src

To check whether an existing object supports =using= at runtime:

#+begin_src typescript
import { DatabaseSync } from 'node:sqlite'

const db = new DatabaseSync(':memory:')
console.log(Symbol.dispose in db)       // true — safe to use with `using`
console.log(Symbol.asyncDispose in db)  // false — not async-disposable
#+end_src

** Scope and Lifetime

=using= is block-scoped, exactly like =const= and =let=. The resource
lives from its declaration to the closing brace of its enclosing block:

#+begin_src typescript
function processBooks(): void {
  // db is acquired here
  using db = createDatabaseConnection()

  if (someCondition) {
    return  // db is disposed here — the early return is safe
  }

  db.prepare('UPDATE books SET processed = 1').run()
  // db is disposed here — end of function scope
}
#+end_src

#+begin_quote
*Key insight:* every exit path from the scope — normal completion,
early =return=, thrown exception, =break= from a loop — triggers
disposal. You cannot escape it.
#+end_quote

** LIFO Disposal Order with Multiple Resources

When you declare multiple =using= variables in the same scope, they
are disposed in *reverse declaration order* (last-in, first-out). This
mirrors the natural dependency direction: if =b= was created using =a=,
then =b= should be torn down before =a=.

#+begin_src typescript
function exportData(): void {
  // ✅ GOOD — clean, flat, correct disposal order
  using db   = createDatabaseConnection()   // acquired 1st, disposed 3rd
  using file = openOutputFile('./out.csv')  // acquired 2nd, disposed 2nd
  using lock = acquireLock('export')        // acquired 3rd, disposed 1st

  writeExport(db, file, lock)
  // On exit: lock → file → db (LIFO)
}
#+end_src

Compare this to the manual nested =try/finally= pyramid shown earlier.
Same behaviour, zero nesting.

** Error Aggregation with =SuppressedError=

When the body of a =using= block throws *and* a disposer also throws,
JavaScript wraps both in a =SuppressedError=:

#+begin_src typescript
{
  using db = createDatabaseConnection()
  throw new Error('query failed')
  // db[Symbol.dispose]() also throws: Error('connection already closed')
}
// Caught: SuppressedError {
//   error:     Error('connection already closed'),   ← the disposal error
//   suppressed: Error('query failed'),                ← the original error
// }
#+end_src

The original error is preserved as =suppressed= — you can always
inspect it. With plain =try/finally=, the original error is silently
overwritten by the cleanup error.

#+begin_src typescript
// Inspecting a SuppressedError
try {
  using db = createDatabaseConnection()
  throw new Error('query failed')
} catch (e) {
  if (e instanceof SuppressedError) {
    console.error('Original error:', e.suppressed)  // Error: query failed
    console.error('Disposal error:', e.error)        // Error: already closed
  }
}
#+end_src

-----

* =await using=: Asynchronous Disposal

** When Synchronous Cleanup Is Not Enough

Some resources cannot be closed synchronously. Examples:

- A network connection that must flush buffered writes before closing
- A message queue consumer that must finish processing in-flight messages
- A file stream that must be drained before the handle is released

For these, implement =Symbol.asyncDispose= and use =await using=:

#+begin_src typescript
class AsyncDatabasePool {
  private pool: Pool

  constructor() {
    this.pool = createPool({ max: 10 })
  }

  async query(sql: string): Promise<Row[]> {
    return this.pool.query(sql)
  }

  // Makes this class compatible with `await using`
  async [Symbol.asyncDispose](): Promise<void> {
    await this.pool.drain()   // wait for in-flight queries to complete
    await this.pool.clear()   // release all connections
  }
}
#+end_src

Usage with =await using= inside an =async= function:

#+begin_src typescript
async function processBatch(): Promise<void> {
  // ✅ GOOD — pool is drained and cleared automatically on exit
  await using pool = new AsyncDatabasePool()

  const rows = await pool.query('SELECT * FROM books WHERE unprocessed = 1')
  await Promise.all(rows.map(processRow))
  // pool[Symbol.asyncDispose]() is awaited here automatically
}
#+end_src

#+begin_quote
*Rule:* =await using= can only appear inside =async= functions or the
top level of ES modules. Just like =await= itself.
#+end_quote

** Comparing =using= and =await using=

#+begin_src typescript
// Synchronous disposal — use when cleanup is instant
{
  using db = new DatabaseSync(':memory:')
  db.exec('CREATE TABLE t (id INTEGER)')
  // db.close() called synchronously on exit
}

// Asynchronous disposal — use when cleanup requires I/O
async function run(): Promise<void> {
  await using pool = new AsyncDatabasePool()
  await pool.query('SELECT 1')
  // await pool[Symbol.asyncDispose]() called on exit
}
#+end_src

** Mixed Sync and Async in One Scope

You can mix =using= and =await using= in the same =async= function.
All disposers run on exit in LIFO order, and async ones are awaited:

#+begin_src typescript
async function syncAndAsync(): Promise<void> {
  using   syncLock  = acquireLock('write')        // Symbol.dispose
  await using pool  = new AsyncDatabasePool()     // Symbol.asyncDispose

  await pool.query('UPDATE books SET exported = 1')
  // On exit:
  //   1. await pool[Symbol.asyncDispose]()  (LIFO: declared last, disposed first)
  //   2. syncLock[Symbol.dispose]()
}
#+end_src

-----

* Solutions and Patterns

** Pattern 1: Single Resource (most common)

#+begin_src typescript
// ❌ BEFORE — manual cleanup
function getBookCount(): number {
  const db = createDatabaseConnection()
  try {
    const result = db.prepare('SELECT COUNT(*) as n FROM books').get() as { n: number }
    return result.n
  } finally {
    db.close()
  }
}

// ✅ AFTER — using
function getBookCount(): number {
  using db = createDatabaseConnection()
  const result = db.prepare('SELECT COUNT(*) as n FROM books').get() as { n: number }
  return result.n
  // db.close() happens here automatically
}
#+end_src

** Pattern 2: Multiple Resources (pyramid eliminated)

#+begin_src typescript
// ❌ BEFORE — nested try/finally pyramid
function exportBooks(): void {
  const db = createDatabaseConnection()
  try {
    const file = openFile('./export.csv', 'w')
    try {
      writeBooks(db, file)
    } finally {
      file.close()
    }
  } finally {
    db.close()
  }
}

// ✅ AFTER — flat and readable
function exportBooks(): void {
  using db   = createDatabaseConnection()
  using file = openFile('./export.csv', 'w')
  writeBooks(db, file)
  // file.close() then db.close() — LIFO
}
#+end_src

** Pattern 3: Conditional Resource

=using= allows =null= and =undefined= — the disposal step is simply
skipped if the value is nullish. This is useful when a resource is
optionally acquired:

#+begin_src typescript
// ✅ GOOD — no disposal attempted when db is null
function tryGetBook(id: number): Book | null {
  using db = isFeatureEnabled() ? createDatabaseConnection() : null
  return db?.prepare('SELECT * FROM books WHERE id = ?').get(id) as Book | null
}
#+end_src

** Pattern 4: Making a Third-Party Class Disposable

Not all libraries implement =Symbol.dispose=. You can add it without
subclassing using a wrapper:

#+begin_src typescript
// Third-party class with no Symbol.dispose
import { SomeConnection } from 'some-library'

// ✅ GOOD — thin disposable wrapper
class DisposableConnection implements Disposable {
  readonly inner: SomeConnection

  constructor(config: ConnectionConfig) {
    this.inner = new SomeConnection(config)
  }

  [Symbol.dispose](): void {
    this.inner.close()
  }
}

// Usage
function run(): void {
  using conn = new DisposableConnection({ host: 'localhost' })
  conn.inner.query('SELECT 1')
}
#+end_src

-----

* Common Anti-Patterns

*** Anti-Pattern 1: Using =using= at Module Top-Level in a Script

=using= cannot be used at the top level of a *script* (a non-module
file) because the scope never exits while the process is running.

#+begin_src typescript
// ❌ BAD — SyntaxError: 'using' declarations may not appear at the top level of a script
using db = createDatabaseConnection()
export { db }
#+end_src

#+begin_src typescript
// ✅ GOOD — wrap in a function, or use at the top level of an ES module
export function getDb(): DatabaseSync {
  using db = createDatabaseConnection()
  return db.prepare('SELECT 1').get()
  // db is disposed before this function returns
}
#+end_src

Note: exporting the =using= variable itself is also problematic —
the consumer receives an already-disposed resource. Pass derived
values out, not the resource itself.

*** Anti-Pattern 2: Returning the =using= Variable Directly

The resource is disposed *before* the function returns its value to
the caller. If you return the resource itself, the caller receives a
closed handle.

#+begin_src typescript
// ❌ BAD — caller receives a disposed DatabaseSync
function openDb(): DatabaseSync {
  using db = createDatabaseConnection()
  return db  // db.close() fires HERE, before the caller can use it
}

const db = openDb()
db.prepare('SELECT 1')  // Error: database connection is closed
#+end_src

#+begin_src typescript
// ✅ GOOD — return the result of using the resource, not the resource itself
function getBookCount(): number {
  using db = createDatabaseConnection()
  const result = db.prepare('SELECT COUNT(*) as n FROM books').get() as { n: number }
  return result.n  // primitive value — safe to return
}
#+end_src

*** Anti-Pattern 3: Using =using= Without TypeScript Configuration

Without the correct =tsconfig.json= settings, TypeScript will reject
=using= declarations.

#+begin_src json
// ❌ BAD — missing target and lib entries
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM"]
  }
}
#+end_src

#+begin_src json
// ✅ GOOD — ES2024 target + esnext.disposable lib entry
{
  "compilerOptions": {
    "target": "ES2024",
    "lib": ["ES2024", "DOM", "DOM.Iterable", "esnext.disposable"]
  }
}
#+end_src

*** Anti-Pattern 4: Using =await using= in a Synchronous Function

=await using= requires an =async= context — it calls
=Symbol.asyncDispose= with =await=. In a synchronous function this is
a compile-time error.

#+begin_src typescript
// ❌ BAD — compile error: await using requires an async context
function syncFn(): void {
  await using pool = new AsyncDatabasePool()
  pool.query('SELECT 1')
}
#+end_src

#+begin_src typescript
// ✅ GOOD — make the function async
async function asyncFn(): Promise<void> {
  await using pool = new AsyncDatabasePool()
  await pool.query('SELECT 1')
}
#+end_src

-----

* Best Practices

*** 1. Prefer =using= over =try/finally= for resource cleanup

If the resource implements =Symbol.dispose=, always prefer =using=.
It is shorter, flatter, and impossible to forget.

#+begin_src typescript
// ✅ Good: using handles all exit paths
using db = createDatabaseConnection()
doWork(db)

// ❌ Bad: try/finally is verbose and easy to omit
const db = createDatabaseConnection()
try {
  doWork(db)
} finally {
  db.close()
}
#+end_src

*** 2. Implement =Symbol.dispose= on all resource classes you own

Any class that wraps a resource (connection, handle, lock) should
implement =[Symbol.dispose]()=. It costs one method and unlocks
=using= for all consumers.

#+begin_src typescript
// ✅ Good: disposable by design
class BookRepository implements Disposable {
  private db: DatabaseSync

  constructor(path: string) { this.db = new DatabaseSync(path) }

  findById(id: number): Book | null {
    return this.db.prepare('SELECT * FROM books WHERE id = ?').get(id) as Book | null
  }

  [Symbol.dispose](): void { this.db.close() }
}
#+end_src

*** 3. Check for =Symbol.dispose= before assuming compatibility

Not every Node.js built-in or third-party class supports =using= yet.
Verify at the call site before relying on it.

#+begin_src typescript
// ✅ Good: verify support before using
const db = new DatabaseSync(':memory:')
if (Symbol.dispose in db) {
  using safeDb = db
  safeDb.exec('CREATE TABLE t (id INTEGER)')
} else {
  // fall back to try/finally
}
#+end_src

*** 4. Use =await using= only when cleanup genuinely needs to be async

Do not reach for =await using= by default. If =close()= is
synchronous, use =using=. Unnecessary =async= disposal adds latency
and complexity.

#+begin_src typescript
// ✅ Good: DatabaseSync.close() is sync → use `using`
using db = new DatabaseSync(':memory:')

// ✅ Good: pool.drain() is async → use `await using`
await using pool = new AsyncDatabasePool()
#+end_src

*** 5. Never export a =using=-declared variable to consumers

The resource is disposed when the enclosing scope exits. A consumer
who holds a reference to it will receive a disposed object.

#+begin_src typescript
// ❌ Bad: exported resource will be disposed before consumer uses it
export function getConnection(): DatabaseSync {
  using db = createDatabaseConnection()
  return db  // already disposed on return
}

// ✅ Good: export the result of the operation, not the resource
export function queryBooks(): Book[] {
  using db = createDatabaseConnection()
  return db.prepare('SELECT * FROM books').all() as Book[]
}
#+end_src

*** 6. Reach for =DisposableStack= when you need dynamic resource management

=using= is lexically scoped — you cannot conditionally add resources
to it at runtime. For dynamic cases (e.g. building a list of resources
in a loop), use =DisposableStack=:

#+begin_src typescript
// ✅ Good: DisposableStack for dynamic resource registration
async function openConnections(paths: string[]): Promise<void> {
  using stack = new DisposableStack()

  for (const path of paths) {
    const db = stack.use(new DatabaseSync(path))  // registered for disposal
    db.exec('PRAGMA journal_mode=WAL')
  }
  // All registered databases are closed here in LIFO order
}
#+end_src

-----

* Practice Exercises

*** Exercise 1: Identify the Leak

The following function opens a database connection but has a resource
leak. Identify the leak and explain why it occurs.

#+begin_src typescript
function getLatestBook(): Book | undefined {
  const db = createDatabaseConnection()

  const rows = db.prepare('SELECT * FROM books ORDER BY created_at DESC').all()

  if (rows.length === 0) {
    return undefined  // <- problem here?
  }

  db.close()
  return rows[0] as Book
}
#+end_src

**** Solution
:PROPERTIES:
:VISIBILITY: folded
:END:

*Problem:* When =rows.length === 0=, the function returns =undefined=
via an early =return=. The =db.close()= call at the bottom is never
reached. Every call that finds no books leaks an open connection.

This is exactly the problem =using= solves — all exit paths are
covered, including early returns.

*Fixed:*

#+begin_src typescript
// ✅ using covers the early return path
function getLatestBook(): Book | undefined {
  using db = createDatabaseConnection()

  const rows = db.prepare('SELECT * FROM books ORDER BY created_at DESC').all()

  if (rows.length === 0) {
    return undefined  // db.close() fires here automatically
  }

  return rows[0] as Book  // db.close() fires here too
}
#+end_src

*** Exercise 2: Fix the Pyramid

Refactor the following function to eliminate the nested =try/finally=
structure using =using=.

#+begin_src typescript
function importBooks(csvPath: string): number {
  const db = createDatabaseConnection()
  try {
    const file = openFile(csvPath, 'r')
    try {
      const lock = acquireWriteLock('books')
      try {
        return parseAndInsert(db, file, lock)
      } finally {
        lock.release()
      }
    } finally {
      file.close()
    }
  } finally {
    db.close()
  }
}
#+end_src

**** Solution
:PROPERTIES:
:VISIBILITY: folded
:END:

*Problem:* Three nested =try/finally= blocks — one per resource. This
pattern scales linearly with the number of resources: three resources
means three nesting levels.

*Fixed:*

#+begin_src typescript
// ✅ Flat, readable, correct LIFO disposal order
function importBooks(csvPath: string): number {
  using db   = createDatabaseConnection()    // disposed 3rd
  using file = openFile(csvPath, 'r')        // disposed 2nd
  using lock = acquireWriteLock('books')     // disposed 1st

  return parseAndInsert(db, file, lock)
}
#+end_src

Disposal order: =lock= → =file= → =db= (LIFO). This is the same
order as the original manual code, but expressed without nesting.

*** Exercise 3: Design an Async-Disposable Class

You are building a =MessageQueueConsumer= class that wraps a message
queue client. The client has an async =disconnect()= method that must
be called on cleanup to gracefully drain in-flight messages. Design
the class to be compatible with =await using=.

**** Solution
:PROPERTIES:
:VISIBILITY: folded
:END:

*Design:* implement =Symbol.asyncDispose= returning =Promise<void>=.
The =AsyncDisposable= interface from the =esnext.disposable= lib
describes the contract.

#+begin_src typescript
// ✅ Good: implements AsyncDisposable for use with `await using`
class MessageQueueConsumer implements AsyncDisposable {
  private client: QueueClient

  constructor(config: QueueConfig) {
    this.client = new QueueClient(config)
  }

  async consume(handler: (msg: Message) => Promise<void>): Promise<void> {
    this.client.on('message', handler)
    await this.client.start()
  }

  // Called automatically by `await using`
  async [Symbol.asyncDispose](): Promise<void> {
    await this.client.disconnect()  // drains in-flight messages before closing
  }
}

// Usage
async function runWorker(): Promise<void> {
  await using consumer = new MessageQueueConsumer({ host: 'localhost' })
  await consumer.consume(async (msg) => {
    await processMessage(msg)
  })
  // await consumer[Symbol.asyncDispose]() fires here — queue drains cleanly
}
#+end_src

*** Exercise 4: Trace the Disposal Order

Given the following function, list every disposal event in the exact
order they occur, including what happens when =processRow= throws.

#+begin_src typescript
async function processAllBooks(): Promise<void> {
  using   dbA  = createDatabaseConnection()
  await using pool = new AsyncDatabasePool()
  using   lock = acquireWriteLock('books')

  const rows = await pool.query('SELECT * FROM books')
  for (const row of rows) {
    await processRow(dbA, row)  // throws Error('row 42 invalid') for one row
  }
}
#+end_src

**** Solution
:PROPERTIES:
:VISIBILITY: folded
:END:

When =processRow= throws, the scope exits via exception. Disposal
runs in LIFO order — last declared is first disposed:

1. =lock[Symbol.dispose]()= — synchronous, runs immediately
2. =await pool[Symbol.asyncDispose]()= — async, awaited before continuing
3. =dbA[Symbol.dispose]()= — synchronous, runs last

The =Error('row 42 invalid')= is re-thrown after all disposal is
complete. If any disposer also throws, the original error becomes the
=suppressed= property of a =SuppressedError=.

The caller catches the error (or its =SuppressedError= wrapper) with
all three resources guaranteed closed — regardless of which exit path
was taken.

-----

* Summary

** Key Takeaways

1. =using= declares a block-scoped resource that is *automatically
   disposed* when the scope exits — on any exit path including throws,
   early returns, and =break=.
2. =await using= is the async counterpart — use it when the disposal
   method is async (=Symbol.asyncDispose=).
3. Multiple resources in the same scope are disposed in *LIFO order*
   (last declared, first disposed), matching natural dependency direction.
4. When both the body and a disposer throw, both errors are preserved
   in a =SuppressedError= — the original error is never silently lost.
5. TypeScript requires =target: "ES2024"= and =lib: ["esnext.disposable"]=
   to compile =using= and =await using= declarations.
6. Never return a =using=-declared variable to a caller — it will be
   disposed before the caller can use it.
7. Use =DisposableStack= when you need to register resources dynamically
   rather than lexically.

** Quick Reference

| Scenario                             | Declaration    | Method implemented        |
|--------------------------------------+----------------+---------------------------|
| Sync cleanup (=close()=, =release()=)| =using=        | =[Symbol.dispose]()=      |
| Async cleanup (=drain()=, =flush()=) | =await using=  | =[Symbol.asyncDispose]()= |
| Dynamic resource list                | =DisposableStack= | N/A                    |
| Optional resource (may be null)      | =using x = condition ? res : null= | =[Symbol.dispose]()= |

| Common mistake                    | Why it fails                              |
|-----------------------------------+-------------------------------------------|
| Returning the =using= variable    | Resource is disposed before caller gets it |
| =await using= in a sync function  | Compile error — no async context           |
| =using= at script top level       | Scope never exits — syntax error           |
| Missing =esnext.disposable= lib   | =Symbol.dispose= type not found            |

-----

* Related Documents

- [[./teachingStyleguide.org][Teaching Document Style Guide]] — How to write teaching documents in this codebase

-----

* Further Reading

- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/using][using — JavaScript | MDN]] — Syntax, semantics, and browser compatibility
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/await_using][await using — JavaScript | MDN]] — The async counterpart
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Resource_management][Resource Management Guide — MDN]] — Broader guide on JS resource management
- [[https://github.com/tc39/proposal-explicit-resource-management][TC39 Proposal — Explicit Resource Management]] — The original proposal with motivation and full specification
- [[https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html][TypeScript 5.2 Release Notes]] — Official TS announcement with examples

-----

*Questions or suggestions?* File an issue or submit a PR to improve this guide!
